
#### 여러 가지 쉘
| 이름            | 쉘                                                                                                                                                                                             |
| :---------------: | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| sh <br>(에스에이치) | 가장 기본적인 명령어 처리 능력을 가지고 있는 쉘로, b쉘 이라고 부른다.<br>동작은 빠르지만, 기능 면에서는 다른 쉘에 비해 빈약하기 때문에 주로 쉘 스크립트의 실행 환경 등에 사용되는 경우가 많다. |
| bash <br>(배쉬)     | b쉘을 확장한 쉘로, 현재는 이것을 b쉘이라 부르는 경우도 있다.<br>Linux에서는 표준 쉘로 채택되어 있으며, 가장 널리 알려진 쉘이라 할 수 있다.                                                     |
| ksh <br>(k쉘)       | b쉘을 확장한 쉘로, AT&T사가 개발했으며, 상용 UNIX로 사용되고 있다.                                                                                                                             |
| csh <br>(c쉘)       | 주로 BSD계열에서 채택되고 있는 쉘로, c쉘이라고 부른다. <br>C언어적 명령어 구문을 가지고 있는 것이 특징이다.                                                                                    |
| tcsh <br>(tc쉘)     | c쉘을 확장한 쉘로 현재의 BSD 계열 OS에서는 표준 쉘이다.<br> bash와 함께 많이 사용하는 쉘이다.                                                                                                  |
| zsh <br>(z쉘)       | b쉘을 확장한 쉘이지만, tcsh 기능도 갖고 있다. <br>b쉘 계열과 c쉘의 두 기능을 모두 사용할 수 있지만, 대신 동작이 느린 단점이 있다.                                                                  |

#### 주요 디렉터리
| 디렉터리 | 역할                                                                                          |
| :--------: | --------------------------------------------------------------------------------------------- |
| bin      | 바이너리 형식의 실행 파일이나 명령이 보관되어 있다.                                           |
| dev      | 디바이스 관련 파일이 보관되어 있다.                                                           |
| etc      | 각종 설정 파일 등 다양한 파일이 보관되어 있다.                                                |
| root     | 루트 디렉터리와는 별도로 준비된 시스템 관리자용인 홈 디렉터리이다.                            |
| sbin     | 관리자용 시스템 표준 명령이 보관되어 있다.                                                    |
| usr      | 각 사용자의 데이터나 애플리케이션이 보관되어 있는 장소이다.                                   |
| home     | 이 디렉터리 아래에 사용자별 디렉터리가 만들어지고, <br>거기가 각 사용자의 홈 디렉터리가 된다. |
| var      | 애플리케이션의 기록(로그) 파일이나 메일 데이터 등이 보관되어 있는 장소이다.                   |

#### 파일 시스템의 종류
- Linux에서 사용되는 주요 파일 시스템에 대해 알아본다.

| 파일 시스템 | 특징                                                                                                                                                            |
| ----------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| ext4        | Linux의 표준 파일 시스템으로 채택된 ext(EXTended file system)의 후속이다.<br>현재도 많은 Linux 디스트리뷰션의 디폴트 파일 시스템으로 되어 있다.                 |
| JFS         | IBM이 개발한 파일 시스템이 기반이며, Linux에서는 커널 2.6이 표준으로 채택되었다.<br>기존의 파일 시스템에 비해 신뢰성이 높으며 접속 속도가 빠르다는 특징이 있다. |
| XFS         | SGI사가 개발한 파일 시스템을 이식한 것으로, 병렬 입출력 조작이 뛰어나다.                                                                                        |

- 가상 파일 시스템 
	- 파일이 많은 경우 하드 디스크나 SSD에 저장되지만, 메모리 일부를 파일 시스템으로 사용한 것을 **가상 파일 시스템**이라고 한다. 가상 파일 시스템의 예로는 tmpfs나 devtmpfs와 같은 것들이 있다. 

##### 파일의 압축과 풀기 in Linux
- Linux에서는 크기를 작게 압축하여, 여러 개의 파일로 정리하는 것을 아카이브라고 하여 구별한다. 
- 이때, **아카이브**된 파일을 원래대로 되돌리는 것을 **해제**라고 한다. 
- 그러나, windows에서는 푸는 것을 해제라고 부르고 있어 용어가 혼용되는 경우가 있다. 

- window에서는 ZIP이라는 압축형식이 유명하지만, Linux의 경우는 종류가 많고, 표준 압축 방식에 대해서는 이에 대응한 명령이 준비되어 있다. 

| 주요 명령어   | 기능                                                 |
| :------------: | :--------------------------------------------------: |
| gzip / gunzip | 압축 / 해제                                          |
| zip / unzip   | 압축 / 해제                                          |
| tar           | 아카이브, 생성, 압축, 해제<br>(하나의 명령으로 대응) |

- tar 압축 파일의 경우, 아카이브만 하면 확장자가 `.tar` 인 파일이 만들어지고, 옵션을 사용한 압축까지 한 경우 `.tar.gz`와 같이 두 개의 확장자가 나란히 있는 파일이 만들어진다.

#### 절대경로와 상대경로 
##### 절대경로
- **루트 디렉터리**를 기점으로 지정하는 방법이다. 이 표시 방법은 **커런트 디렉터리**(현재 표시하고 있는 디렉터리)가 어디에 있든 상관없이 확실하게 목적한 파일을 지정할 수 있다. 
	- `/` (root dir)
		- `/`는 경로의 맨 처음이나 단독으로 사용하는 경우 **루트 디렉터리**를 나타낸다. 
```shell
/home/beginner/sample.txt
```

##### 상대경로 
- 커런트 디렉터리를 기점으로 지정하는 방법이다. 아래 그림에서 커런트 디렉터리를 beginner 디렉터리로 했을 경우를 살펴보자.
	- `./..`
		- `'..'`은 하나 위의 디렉터리(부모 디렉터리)를 나타낸다.
	- `.`
		- `'.'`는 커런트 디렉터리를 나타낸다. 
		- 커런트 디렉터리의 상대경로 `'./'`는 생략할 수 있다. 
```shell
# 현재 beginner 라는 폴더에 위치하고, 내부에 sample.txt 라는 파일이 있다.
./sample.txt 
또는 
sample.txt

# home 폴더 아래에 picture과 beginner 라는 이름의 폴더가 있다. 
# 커런트 폴더 -> beginner
./.. => home 폴더
./../picture
```

- 홈 디렉터리를 표시할 때 `'~'` (tilde)로 나타내기도 한다.

### 기본 명령어
#### 디렉터리의 이동과 파일 표시 관련
##### cd
- cd(Change Directory): 디렉터리 이동 
```shell
cd dir_name
# 이때 절대경로, 상대경로 무관

cd 
# 단독으로 쓰이면, 홈 디렉터리로 이동
```

##### pwd
- pwd(Print work Directory): 커런트 디렉터리의 절대 경로를 표시

##### ls
- ls(List directory): 디렉터리 정보를 조사
```shell
# /beginner/data/ 밑에 a, b 폴더와 sample1.txt, sample2.txt 가 있을 때
ls data
>>> a b sample1.txt sample2.txt

# 디렉터리명 또는 파일명을 생략하면 커런트 디렉터리에 대한 내용을 표시
ls 

ls -1 # 상세정보가 나타난다.
ls -a # 숨김파일 (.dot 파일)도 전부 나타낸다. 

```


#### 파일 및 디렉터리 작성/삭제 관련
##### touch
- 파일 생성
```shell
touch test1
touch sample.txt
```
##### mv
- mv(MoVe file): 파일명을 변경하거나 파일을 이동할 때 사용
```shell
# 1. 파일명 변경
# mv [원래이름] [변경후이름]
mv sample1.txt sample

# 2. 파일 이동
# mv [이동하고자하는 파일명] [이동할 디렉터리 경로]
mv sample data
```
- 📌파일명과 같은 이름의 디렉터리가 있는 경우 경로를 올바르게 입력하지 않으면 '파일명 변경' 대신 '파일 이동'이 실행될 수 있으니 주의!

##### cp
- cp(CoPy file): 파일을 복사할 때 사용하는 명령
```shell
# cp [복사하고자 하는 파일명] [복사할 디렉터리 경로]
cp sample3.txt data
```

##### mkdir
- mkdir(MaKe DIRectory): 새로운 디렉터리 생성
```shell
mkdir temp
```

##### rmdir 
- rmdir(ReMove DIRectory): 빈 디렉터리 삭제 명령
```shell
rmdir temp
```

##### rm
- rm(ReMove file): 파일이나 디렉터리 삭제 명령
```shell
rm sample3.txt

# 파일이나 디렉터리가 들어있는 디렉터리(내용 포함)를 삭제하는 옵션
rm -r temp
```

#### 파일 조작 관련
##### cat
- cat(conCATenate): 파일의 내용 열람
```plain
# sample1.txt

I love Linux
```

```shell
$ cat sample1.txt
>>> I love Linux
```

- 파일명을 지정하지 않으면 키보드 입력 대기 상태가 되어 키보드로 입력한 내용을 반복적으로 표시한다. 
```shell
$ cat
>>> test
test
>>> test2
test2
>>>
```
- 입력 대기 해제시에는 `ctrl + c`를 사용한다. 

##### sort
- sort 명려은 지정한 텍스트 파일 내용을 정렬하여 표시한다. 
- 옵션이 없으면 오름차순(알파벳), `-r`을 붙이면 역순(내림차순)으로 정렬한다.

```plain
# cat.txt
kkoma
alex
ran
sham
```

```shell
$ sort cat.txt
alex
kkoma
ran
sham
```

- 이때, 파일명을 지정하지 않으면 키보드 입력 대기 상태가 되고, `ctrl + D` 를 누르면 입력한 내용을 정렬하여 표시한다. (bash의 경우)
	- **쉘에 따라서 로그아웃하는 경우도 있으니 주의!**

```shell
$ sort
>>> dog 
>>> mouse
>>> bird
# 여기서 ctrl + D 를 누르면
bird
dog
mouse
```

##### grep
- grep (Global Regular Expression Print) : 여러 파일 중에서 문자열을 검색하는 명령

```plain
# linenumber1
sinseol-dong
dongdaemun
jongro 5-ga
jongro 3-ga
jonggak
```

```shell
# grep [검색할 문자열(정규표현)] [파일명(경로)]
$ grep jongno linenumber1
>>> jongno 5-ga
>>> jongno 3-ga
```
- 지정한 문자열을 포함한 모든 행이 표시된다.

#### 파일 및 명령을 검색하는 명령관련
##### find
- 파일을 검색하기 위한 명령. 닷 파일도 검색이 가능하다.
- 커런트 디렉터리 이하 모든 폴더와 파일에 대해 검색을 한다.
```shell
find namelist # 파일명 또는 임의의 문자열

# find [검색 시작 디렉터리] [파일명 또는 임의의 문자열]
find data namelsit
```

##### which
- 지정된 명형의 본체를 검색하여 그 절대경로를 표시한다. 
```shell
# which [명령이름]
which ls
>>> /bin/ls # ls 명령의 절대경로가 표시된다.
```

##### whereis
- 명령 경로 뿐만 아니라, 매뉴얼이나 소스코드 파일 등의 경로도 동시에 조사하여 표시한다. 
```shell 
# whereis [명령이름]
whereis ls
```


#### 와일드 카드
##### *
- `find a*` 에서, `'a*'`은 **첫 글자가 a이면 그 후의 문자는 무엇이든 괜찮다**라는 의미
- 임의의 0개 이상의 문자열을 나타냄
##### ?
- 한 개의 문자열
- `find a?` 라는 명령은 **a로 시작하는 두 문자의 문자열을 검색하라**는 의미

- 와일드 카드는 문자열의 전후, 혹은 사이에 껴있어도 가능하다.
	- `*sample`, `pict?data` 등

- 주요 와일드 카드
| 기호           | 기능                              | 표기 예               | 의미                                               |
| :--------------: | :--------------------------------: | :---------------------: | :-------------------------------------------------- |
| [ ]             | [] 안의 임의의 1문자              | `[dog]` <br>`[a-z]`   | d,o,g라는 세개의 문자<br>a부터 z까지의 모든 알파벳 |
| `[^]`<br>`[!]` | []안의 문자열 이외의 임의의 1문자 | `[^dog]` <br>`[!dog]` | d, o, g 이외의 문자                                |
| {}             | {} 안에 지정된 각각의 문자열      | {dog, rat}            | dog, rat 이라는 두개의 문자열                      |


#### vi 실행과 종료
##### vi 실행
```shell
# vi 실행
vi

vi sample1.txt
```
- 파일명을 지정하여 실행할 경우, 기존에 있는 파일명을 지정하면 그 파일을 열고, 새로운 파일명을 지정하면 그 이름의 파일을 새로 만들 수 있다. 지정하지 않으면 파일명이 미정인 신규 파일이 열린다. 

##### vi 종료
- `esc` 키를 누르면 명령모드로 전환되고, 이때 `:q!` 라고 입력하면 파일을 저장하지 않고 vi가 종료된다.

##### vi 모드 변경
- vi에는 실행하는 작업에 따라 세가지 모드가 있다.
- vi명령은 소문자인지, 대문자인지에 따라 동작이 다르므로 주의해야 한다.
![](assets/Linux%20note.png)

- 곤란할 때는 ESC
	- vi를 사용하다가 자신이 어떤 모드에 있는지 알 수 없거나, 편집 작업 등으로 혼란스러운 경우에는 `ESC`키를 누른다. 대부분의 경우에는 명령모드로 돌아갈 수 있으므로 거기서 다시 작업을 진행하자.

#### vi 기본 조작
- vi를 실행하면 새로운 행의 왼쪽 끝에 커서가 표시된다. 
- 신규 작성 팡일의 경우는 화면 왼쪽 상단(첫째 행 첫 문자), <br>기존 파일의 경우는 마지막 행의 다음 행 왼쪽 끝에 표시된다.

##### 인서트 모드로 전환하기 위한 키 정리
| 키  | 모드 변경 후의 상태                                           |
|:---:| ------------------------------------------------------------- |
|  i  | 커서 앞(왼쪽에서부터) 문자를 입력할 수 있다.                  |
|  I  | 커서가 있는 행의 맨 앞에 문자를 입력할 수 있다.               |
|  a  | 커서 다음(오른쪽)부터 문자를 입력할 수 있다.                  |
|  A  | 커서가 있는 행의 끝에서 문자를 입력할 수 있다.                |
|  o  | 커서 한 줄 아래에 행을 삽입하고 그곳에 문자를 입력할 수 있다. |
|  O  | 커서 한 줄 위에 행을 삽입하고 그곳에 문자를 입력할 수 있다.   |

#### 저장과 종료
- ex 모드에서 저장하거나 종료할 때 사용하는 명령어.
- 저장, 종료만 각각 수행하는 명령과 같이 수행하는 명령어로 나뉜다.

| 명령      | 기능                           |
| --------- | ------------------------------ |
| :w        | 저장                           |
| :w 파일명 | 다른 이름으로 저장             |
| :w!       | 강제로 저장                    |
| :q        | 파일을 저장하지 않고 종료      |
| :q!       | 파일을 저장하지 않고 강제 종료 |
| :wq       | 파일을 저장하고 종료           |
| :wq!      | 파일을 강제러 저장하고 종료    |

##### vim에서 실수로 강제 종료되었을 때
- Vim은 편집 중인 데이터를 일시적으로 .swp라는 확장자를 가진 파일에 저장한다. 
- 조작 실수 등으로 Vim을 바르게 종료하지 못한 경우에도 .swp 파일은 삭제되지 않고 남아서, 다음에 같은 이름의 파일을 열 때, .swp 파일을 어떻게 할 지 물어본다. 
- 이 때의 옵션은 `R` (Recover :회복)이나 `E` (Edit anyway :강제편집), `Q`(Quit :종료), `A` (Abort :중단)이 있다. 
- .swp 파일은 find 명령 등으로 찾고, 필요 없을 시 rm 명령으로 삭제한다. 

#### 리다이렉트
- 표준 입력, 표준 출력, 표준 오류 출력의 입출력 대상을 변경하는 것을 **리다이렉트**(또는 **리다이렉션**)라고 한다. 

##### 출력 대상 지정
```shell
명령 > sample1.txt # 출력 대상 경로
```
- 이때, `>`는 저장(덮어쓰기), `>>`는 추가저장을 의미한다. 
	- 오류 출력의 경우는 `2>` 또는 `2>>` 을 의미한다. 

##### 입력 대상의 지정
```shell 
명령 < sample2.txt # 입력 대상의 경로
```

##### 예시
```shell
sort < sample1.txt > sample2.txt
# 이때 sample1 → 정렬 대상이 되는 파일(입력)
# sample2 → 저장할 곳의 경로(출력)
```


#### 파이프란? 
- 명령에 의해 얻은 결과를 다른 명령에 넘겨주고 싶을 때 사용한다.
```shell
ls | more
```
- more : 출력 결과를 페이지 단위로 표시하는 명령
- 파이프는 명령이 세개 이상 있어도 연결할 수 있다.

```shell
ls / | grep sr
# 루트 디렉토리를 조사하는데, 이 때 문자열 'sr'이 포함된 결과를 찾아라 
```


### 파일 관련 명령
##### 텍스트 출력 페이징
- more 명령과 less 명령은 화면(페이지)을 기준으로 출력 결과를 표시(페이징) 한다. 
- 출력 행이 많은 경우 장동으로 스크롤되는 것을 방지할 수 있으며, 이런 명령을 **페이저**라고 한다.

###### more 명령

```plain
# pet.txt 내용
...
kkoma
alex
ran
sham
...
```

```shell
more pet.txt # 파일명

>>>

...
kkoma
alex
ran
sham
--More--
```

- 출력 결과가 화면에 다 표시되지 않은 경우, 1페이지분이 표시된 후 `--More--`이 표시되고, 내부 명령어는 입력 대기 상태가 된다. 이때 사용 가능한 명령어는 아래와 같다.  
	- 스페이스 → 다음 페이지를 표시
	- enter → 1행씩 스크롤
	- h → 도움말
	- q → 종료

###### less 명령
- 내부 명령이 more 보다 강화되어 있어 간단한 검색이나 점프 이동이 가능하다. 
- 끝까지 표시되어도 자동으로 종료되지 않으므로 'q'를 입력하여 종료한다.
```shell
less pet.txt # 파일명

>>>
...
kkoma
alex
ran
sham
...
```
- 이때, 사용 가능한 내부 명령은 다음과 같다. 

###### 내부 명령
| 명령어          | 기능                             |
| :--------------: | -------------------------------- |
| 스페이스 또는 z | 다음 페이지를 표시               |
| w               | 이전 페이지를 표시               |
| Enter           | 1행씩 스크롤                     |
| < 또는 q        | 맨 앞으로 점프                   |
| > 또는 G        | 맨 끝으로 점프                   |
| / 문자열        | 문자열을 앞으로 검색(/로 재검색) |
| ? 문자열        | 문자열을 뒤로 검색 (?로 재검색)  |
| h               | 도움말                           |
| q               | 종료                             |

- 예시
	- 표시 결과가 많을 경우에 less 명령을 파이프 하면 좋다. 
	- `ls -1 /var/log | less`


#### alias 작성하기
- 자주 사용하는 명령의 경우 몇 번이나 같은 인수나 옵션을 입력하는 것은 번거로운 일이다. 
- 이럴 때, alias 명령을 사용하여 옵션이나 인수를 포함한 명령 기술 내용 자체에 대해 별명(alias)을 설정할 수 있다. 

```shell
alias la='ls -a'
# alias 별명='명령문'
# 별명(alias)에는 기존의 명령 이름은 사용할 수 없다.
```

##### alias 목록 표시하기
- 인수나 옵션을 붙이지 않고, alias 명령을 실행하면 현재 이영 가능한 에일리어스를 표시할 수 있다. 
```shell
alias
```

![](assets/Linux%20note-1.png)

##### alias 삭제하기
```shell
unalias la # 별명(alias)
```


#### 링크 작성하기
- ln 명령어(Link) 명령은 파일이나 디렉터리에 대한 **링크(링크 파일)** 을 만든다.
- 링크에는 **심볼릭 링크와 하드 링크** 두 종류가 있다.
```shell
# ln [옵션명] [링크의 참조대상] [링크명]
ln -s /home/beginner/sample1.txt sample
```

- 이때 옵션(-s)이 붙으면 심볼릭 링크, 없으면 하드링크이다.
```shell
ln -s /home/beginner/sample1.txt sample # 심볼릭 링크
ln /home/beginner/sample1.txt sample # 하드 링크
```

##### 심볼릭 링크와 하드 링크
- 심볼릭 링크 → 파일로의 참조
	- 링크를 삭제해도 원래의 파일에는 영향이 없다
	- 본체를 삭제하면 링크가 끊어진다.
- 하드링크 → 파일 실체로의 참조
	- 보통의 파일은 실체와 이름이 1:1 관계이다.
	- 하드링크를 만들면 하나의 파일을 두 개의 이름으로 참조할 수 있다. 

#### 명령 종류 알아보기 
```shell 
type ps
```

- 내부 명령인 경우
![](assets/Linux%20note-2.png)

- 외부 명령인 경우
![](assets/Linux%20note-3.png)

- alias인 경우
![](assets/Linux%20note-4.png)

#### 파일의 타임스탬프 확인/ 변경하기
- 파일에는 갱신 일시나 접속일시가 기록되어 있는데, 이것들을 **stat** 명령으로 알 수 있다. 
![](assets/Linux%20note-5.png)

- touch 명령을 사용하면 파일의 타임스탬프를 변경할 수 있다. 
```shell
touch -md "2023-05-18 12:00:00" abc.txt # vkdlfaud
# m 으로 변경 일시, a로 접속일 시를 변경한다.
# 둘다 지정하지 않으면 양쪽 모두 수정한다. 

# d로 일시를 지정한다. 
# 지정하지 않으면 현재 일시가 된다.
```

- 파일명만 지정해서 실행아면 크기가 0인 빈 파일이 만들어 진다. 
```shell
touch test.py
touch .gitignore
```


#### 메모리와 디스크 명령
- free, df, du 명령은 디폴트로는 결과의 단위가 KB이다. 
- -h 옵션을 붙이면 읽기 쉬운 당위로 표시할 수 있다. 

##### 메모리 사용량 알아보기 
- free 명령을 사용해서 메모리 사용량을 알 수 있고, 스왑(교체) 파일(메모리가 사용하지 않는 부분을 일시적으로 디스크에 옮긴 파일)의 크기도 확인 할 수 있다. 
```shell
free
```

##### 디스크의 사용량 알아보기 
- df 명령을 사용하여 디렉터리와 파일 시스템의 관계와 사용량을 알 수 있다.
```shell
df
``` 

##### 파일 및 디렉터리의 크기 알아보기
- du 명령은 지정한 파일의 크기 및 디렉터리 사용량을 표시하는 명령어 이다.
```shell
du -a diary.txt
# -a → 파일 단위로 크리를 표시
```

- 파일명(또는 디렉터리명)을 지정하지 않은 경우는 커런트 디렉터리 아래의 모든 디렉터리를 조사하여 표시한다. 
```shell
du - a | less

```

![](assets/Linux%20note-6.png)
- 사용량(kb) 와 파일명이 표시된다.

#### 사용자 관련 명령
##### 사용자의 로그인 상황 확인하기
- w 명령은 현재 로그인 중인 사용자와 그 사람이 무엇을 하고 있는지 정보를 표시한다. 
```shell
w
```

- 비슷한 명령어로 who 가 있다. 이는 사용자명롸 로그인 일시를 표시한다. 
```shell
who
```

##### 비밀번호 변경하기
- passwd 명령은 사용자 계정의 비밀번호에 관한 성정을 변경하는 명령이다. 
- 일반 사용자는 자신의 계정만 조작할 수 있다. 
```shell
passwd
```

- 관리자는 모든 사용자의 비밀번호를 리셋할 수 있다. 이 경우는 다음과 같이 사용자 계정을 지정한다.
	- 관리자는 특정 사용자 계정의 비활성화 또는 비밀번호 유효기간을 바꿀 수도 있다.
```shell
passwd mario # 비밀번호를 리셋하고 싶은 사용자 계정
```


#### 명령 이력 알아보기 
- history 명령을 사용하면 과거에 입력한 명령을 표시할 수 있다. 
```shell
history 5 # 표시 건수 (history 명령 포함)
```

![](assets/Linux%20note-7.png)

- 이때 '!' 와 이력번호를 이어서 입력하고 'enter' 키를 누르면 해당 번호에 대응하는 명령을 다시 실행 할 수 있다. 
	- 또는 간편하게 화살표(up/down)을 이용하여 최근  사용한 명령어 부터 다시 불러 올 수 있다. 

#### 입력을 보완하는 기능
- bash 에서는 명령 또는 경로 입력 도중에 `TAB` 키를 누르면 입력할 문자열의 나머지 문자를 보완해 준다.
	- 후보가 2개 이상일 경우 `TAB` 키를 두번 누르면 후보 목록이 표시된다.

### 권한
- 권한이란 파일이나 디렉터리에 때해 사용자나 그룹이 가지는 권리를 말한다. 
- **보호 모드, 허가속성, 액세스 권한**이라고 한다. 
- 세가지 속성
	- 권한에는 읽기, 쓰기, 실행(디렉터리의 이동이나 검색 등도 포함)의 세 가지 속성이 있다. 
- 세가지 사용자 범주
	- User : 파일 소유자(일반적으로는 작성자)
	- Group : User와 같은 그룹의 사용자
	- Other : 그 외의 다른 사용자 

### 권한의 확인
- `ls -1` 또는 `ls -l`
![](assets/Linux%20note-8.png)

![](assets/Linux%20note-9.png)

| 파일 종류 | 의미                   |
| --------- | ---------------------- |
| -         | 일반 파일              |
| d         | 디렉터리               |
| l         | 심볼릭 링크            |
| c         | 캐릭터형 디바이스 파일 |
| b         | 블록형 디바이스 파일   |

- 디바이스 파일?
	- 주변기기에 접속하기 위한 파일이며, 데이터를 다루는 방법에 따라 두 종류로 나뉜다.

| 권한 | 의미                  |
| ---- | --------------------- |
| r    | 읽기 가능 (Readable)  |
| w    | 쓰기 가능 (Writable)  |
| x    | 실행가능 (eXecutable) |
| -    | 불가능 (각 항목 공통) |


#### 권한의 설정
- 모든 파일과 디렉터리에는 초기 상태로 권한이 설정되어 있다. 
- chmod 명령을 사용하면 사용자가 독자적으로 권한을 변경할 수 있다.
```shell
chmod o+w sample.txt
```
![|500](assets/Linux%20note-10.png)

#### 수치를 사용한 권한 설정
| 권한              | 수치 |
| ----------------- | ---- |
| r (읽기 허가)     | 4    |
| w (쓰기 허가)     | 2    |
| x (실행 허가)     | 1    |
| - (허가하지 않음) | 0    |

![](assets/Linux%20note-11.png)

#### 쉘 스크립트
- 쉘에 대한 명령(명령어)를 미리 텍스트 파일에 저장한 것이다.
- 여러 명령을 조합한 일련의 조작을 모아서 실행할 수 있다. 

##### 권한 설정
- 쉘 스크립트 자체로는 명령어들이 모여진 텍스트 파일일 뿐이며, 이를 쉘 스크립트로 기능하기 위해서는 실행 권한을 부여해야 한다. 

```shell
chmod u+x test.sh
```

- 쉘 스크립트 예시
```shell
#! /bin/sh
ls /home
# Ask your name
echo Input your name:
read name
echo "Hello $name"
```

#### Linux의 태스크 처리
- Linux는 여러 태스크(시스템이 수행하는 작업)를 동시에 진행 할 수 있는 **멀티 태스크**를 지원한다. 
- 이때, 하나하나의 태스크를 **프로세스**라고도 하며, Linux환경에서는 OS가 관리하는 단위로 프로세스가 사용되고 있다. 

##### 잡(jobs)
- 파이프로 명령어끼리 연결한 경우 등 하나 이상의 명령(프로세스) 모임을 **잡** 이라고 한다. 잡과 푸로세스는 각각의 고유한 번호를 가지고 있다. 

#### PS
- ps(Process Status) 명령은 현재 가동 중인 프로세스를 ID번호를 붙여 목록으로 표시한다. 
```shell
ps
```

![](assets/Linux%20note-12.png)

#### jobs 명령 
- jobs 명령은 현재 가동 중인 작업을 번호를 붙여 목록으로 표시한다. 

#### kill 명령어 
- 어떤 이유로든 종료하지 못하고 남아 있는 프로세스 또는 잡을 종료하려면 **kill** 명령을 사용한다. 
	- 일반 사용자는 자신이 실행한 프로세스만을 종료할 수 있다. 
```shell
kill 2444 # 프로세스 ID 또는 잡 번호
kill -9 프로세스 ID # 강제 종료시
```


#### 잡 중단과 재개 
- 실행 중인 잡을 일시 중단, 재개 할 수 있다. 중단하려면 `ctrl+z` 를 누른다,
- Vim에서 diary.txt 를 편집하는 도중에 `ctrl+z`를 누르면 잡이 중단되는데, 
- 이때 재개하여면 **fg**(fore ground) 명령으로 잡 번호를 지정하여 실행한다.
	- 잡 번호를 지정하지 않으면 가장 새로운 잡을 재개한다. 


#### 온라인 매뉴얼 참조
- man(MANual) + 명령어
- 해당 명령어의 매뉴얼이 출력된다(기본 less 옵션)
- space로 다음 페이지로 전환, q로 중도에 종료할 수 있다. 
```shell
man ls
```


### 시스템 관리자
#### 사용자의 종류
- Linux 서용자는 크게 관리자와 일반 사용자로 나뉜다. 관리자를 **슈퍼 유저**라고 하며, 계정명은 **root**가 된다. 이 외에 새로 사용자를 만들경우 일반 사용자로 등록되며, 관리자와는 구별된다. 
- Linux에서는 관리자 권한을 가진 계정은 root 하나 뿐이다. 

#### 사용자 전환하기
- 보통의 조작은 일반 수행자가 수행할 것을 권장한다. 그러나 갑자기 환경 설정을 바꿀 필요가 있을 때 root로 다시 로그인하려면 번거롭다. 그럴 때는 **su** 명령을 사용한다. 

##### su 명령
- su 명령(Switch User)은 로그인 중에 다른 사용자로 전환하기 위한 명령이다. 사용자를 지정하지 않고 사용하면 root로 로그인 할 수 있다. 
```shell
su - 
# - 옵션이 붙으면 원래 사용자 환경을 물려받지 않는다. (커런트 디렉터리 등)
# - 옵션이 없으면 원래 사용자 환경을 물려받는다.

su sham # 특정 사용자로 로그인할 경우
```
- 👉 루트 사용자로 로그인한 경우 프롬프트에 `#`이 표시된다.


##### sudo 명령 
- sudo 명령을 입력하면 일시적으로 root의 권한으로 명령을 실행할 수 있다. 
- sudo 명령을 실행하려면 wheel 그룹의 구성원이어야 한다. 

#### 시스템 관리
##### systemd
- CentOS에서는 커널이 실행되면 systemd라는 시스템 환경을 설정하는 프로그램이 실행된다. systemd는 각종 서비스의 프로세스를 실행한다. 
	- systemd가 취급하는 서비스의 예
		- 디스플레이 매니저(GNOME, KDE) 등
		- SSH 서비스
		- FTP 서비스
		- HTTP 웹 서비스

###### 유닛에 의한 관리
- systemd는 각 서비스를 유닛이라는 단위로 관리하고 있다. 따라서 프로세스가 도중에 이상 종료한 경우에도 유닛 내에서는 정합성을 유지하도록 되어 있다.

| 유닛 종별의 예 |                                    |
| -------------- | ---------------------------------- |
| service        | 데모의 실행과 정지를 수행하는 유닛 |
| device         | 디바이스의 감지를 수행하는 유닛    |
| target         | 유닛을 그룹화한 것                 |

- 유닛의 유효, 무효는 systemctl 명령으로 관리 한다. 파리미터를 켜지 않고 실행하면 다음과 같이 유닛의 목록을 표시한다. 

##### 동작모드
- systemd는 default.target이라는 target 유닛의 정보를 바탕으로 프로세스를 실행하는데, 이 내용을 전환해서 다른 모드로 실행하는 것이 가능하다. 

| target            | 기능                     |
| ----------------- | ------------------------ |
| poweroff.target   | 시스템 종료(셧다운)      |
| rescue.target     | 유지관리용 모드          |
| multi-user.target | 멀티유저 모드            |
| graphical-target  | GUI를 통한 멀티유저 모드 |
| reboot.target     | 시스템 재시작            |


### 네트워크 명령
#### 네트워크 어댑터 정보의 확인
- 네트워크 어댑터에 할당된 IP주소 등의 정보를 확인하려면 ifconfig 명령을 사용한다. 
```shell
ifconfig
```

- 단, 최근에는 ifconfig 대신 ip 명령을 사용하는 방법이 권장되고 있다. 같은 결과를 얻으려면 다음과 같이 기술해야 한다. 
```shell
ip addr
```

#### nslookup 명령
- nslookup 명령은 지정한 호스트명(DNS명 또는 IP주소)에 관한 정보를 DNS 서버에서 취득한다. 
```shell
nslookup www.cyber.co.kr
```

![](assets/Linux%20note-13.png)

### 네트워크 설정
- 네트워크를 설정하려면 관리자로 로그인해야 한다. 

#### 설정  파일의 소재
- 네트워크와 관련된 설정은 기본적으로 `/etc/sysconfig` 안에 있는 network라는 파일과 `/etc/sysconfig/network-scripts`안에 있는 설정 파일로 관리되고 있다. 

#### 네트워크 설정의 기본항목
- 네트워크 설정은 다방면에 걸쳐있지만, 여기서는 다음의 여섯 가지 항목에 대해 살펴본다. 
	- 호스트명
	- DNS 서버
	- IP 주소
	- 넷마스크
	- 게이트웨이 주소
	- DHCP의 유무

##### 호스트명의 설정
- 호스트명은 `/etc/hostname` 이라는 텍스트 파일에 기술되어 있다. 
	- centOS 6까지는 `/etc/sysconfig/network`에 저장되어 있다. 

```shell
localhost.localdomain # 완전 수식 도메인명(FQDN)
[호스트명].[도메인명]
```


#### 일시설정
##### 시스템 클락(system clock)
- OS가 내부에 가지고 있는 시계를 **시스템 클락**이라고 한다.
- 파일의 타임스탬프나 사용자의 이용 기록 등을 정확하게 관히하기 위해서라도 시스템 클락의 설정은 중요하다. 
	- 기본적으로는 컴퓨터 본체의 시계(RTC; Real Time Clock 또는 하드웨어 클락)을 기준으로 한다.

##### date 명령
- date 명령은 시스템 클락의 일시를 설정, 관리하는 명령이다. 현재의 일시를 확인하는 방법은 다음과 같다. 
```shell
date # 실행한 순간의 일시가 표시됨
```


##### NTP 서버를 사용한 시간 맞추기
- 네트워크에 연결되어 있는 Linux에서는 NTP(Network Time Protocol) 서버라고 하는 시간 맞춤용 서버를 이용하여 정기적으로 시간을 맞춘다. NTP 서버를 통해 시간을 맞추려면 ntpd라는 데모가 실행되고 있어야 한다. 
	- ntpd는 `/etc/ntp.conf`에 기술된 NTP 서버나 타이밍 정보를 바탕으로 시간을 맞춘다.

##### ntpdate 명령
- ntpdate 명령은 NTP 서버에 문의하여 시간을 동기화한다. 인수에는 다음과 같이 서버명을 지정해야 하며, ntpd가 실행 중인 경우는 사용할 수 없다.
```shell
ntpdate ntp.nict.kr # NTP 서버명
```



#### 사용자의 생성과 삭제 
- 사용자 계정의 생성과 삭제에 대해 알아본다. 
- 이는 모두 관리자에게만 허용된 작업이다. 

##### 사용자 계정 생성
- 먼저 **useradd** 명령을 사용하여 사용자명을 설정한다. 사용자명은 중복해서 설정할 수 없다. 같은 이름의 사용자가 있는 경우에는 이를 알려주는 메시지가 표시된다. **-m** 옵션을 붙여서 사용자용 홈 디렉터리도 함께 작성한다. 

- 그리고 비밀번호는 **passwd** 명령으로 설정한다. 비밀번호를 설정하지 않으면 보안상 문제가 될 뿐만 아니라, 설정에 따라서 비밀번호 없이 로그인할 수 없는 경우도 있다.
```shell
useradd -m testuser # 사용자명

passwd testuser
```

##### 사용자 계정 삭제
- 사용자 계정을 삭제하려면 **userdel** 명령을 사용한다. 
```shell
userdel -r testuser # 사용자명
# -r 옵션 → 계정과 그 홈 디렉터리를 삭제
# 옵션 없음 → 계정만 삭제
```


##### 다중 사용자 모드와 단일 사용자 모드
- Linux에는 여러 명의 사용자가 사용하는 **다중 사용자 모드**와 관리자 한 명만 로그인 할 수 있는 **단일 사용자 모드**가 있다. 단일 사용자 모드는 유지 관리 시 관리자가 안심하고 작업할 수 있도록 준비한 것이다. 


### 그룹 관리 
#### 그룹에서의 관리
- 사용자를 미리 그룹에 소속시켜 놓으면 권한 설정에 따라 그룹에 소속되어 있는 사용자에게 같은 권한을 부여한다. 
- Linux 에서는 사용자 계정 작성 시 사용자 명과 동명의 새로운 그룹이 만들어지며, 거기에 할당된다. 

#### 기본 그룹
- 사용자가 소속된 그룹 중 메인 소속처가 되는 그룹을 기본 그룸(Primary group)이라고 한다. 
	- 기본 그룹 외의 속한 그룹을 하위 그룹(서브 그룹)이라 한다. 

##### 소유 사용자와 소유 그룹
- 파일 및 디렉터리에는 소유 사용자와 소유 그룹이 기록된다. 
- vi 등에서 파일을 새로 만들면 그것을 만든 사용자가 소유 사용자가 되고, 사용자의 기본 그룹이 소유 그룹이 된다. 

##### 소유 사용자와 소유 그룹의 변경
- 소유 사용자는 **chown**(CHange OWNer) 명령으로 소유 그룹은 **chgrp**(CHange GRouP) 명령으로 변경할 수 있다. 
```shell
chown test sample1.txt # 관리자만 이용 가능한 명령어
chgrp hoegye sample1.txt # 관리자와 소유자만 이용 가능
```


#### 그룹 작성
- 새 그룹을 만들거나 삭제하는 방법으로, 관리자만 수행 가능하다. 

##### 그룹 작성
- 그룹 작성 시에 **groupadd**명령을 사용한다.
```shell
groupadd hoegye # 그룹명
```

##### 사용자 등록
- 사용자를 그룹에 등록하여면 **usermod** (USER MODify) 명령을 사용한다. 
- 로그인 중인 사용자의 기본 그룹을 변경하는 경우 변경을 활성화 하려면 다시 로그인 해야 한다. 
```shell
usermod -G hoegye beginner
# usermod [옵션] [그룹명] [사용자명]
```

- 옵션은 `-g` 기본 그룹으로 등록, `-G` 하위 그룹으로 등록, `-aG` 하위 그룹으로 추가 등이 있다.
- 하위 그룹을 기본 그룹으로 만들려면 **newgrp** 명령을 사용한다.
	- 일반 사용자는 본인에 대한 것만 변경 가능
```shell
newgrp hoegye beginner
# newgrp [기본 그룹으로 하고 싶은 그룹명] [사용자명]
```

##### 그룹 삭제
- 그룹을 삭제하려면 **groupdel**명령을 사용한다. 기본 그룹으로 설정한 사용자가 있으면 삭제할 수 없다. 
```shell
groupdel beginner # 그룹명
```

##### 그룹확인 
- 사용자가 어느 그룹에 소속되어 있는지를 확인하는 방법은 여러가지가 있다. 
- 자신의 기본 그룹이나 그 외 소속되어 있는 그룹을 알려면 **id** 명령을 사용하면 된다. 
```shell
id
```

![](assets/Linux%20note-14.png)

- **groups** 명령을 사용하면 자신이 소속된 그룹의 목록만 표시할 수 있다.
```shell
$ groups
>>> 그룹명1, 그룹명2 # 이때, 맨 앞이 기본 그룹
```


### 종료와 재시작
- 시스템을 종료하고나 재시작하는 방법이다. 
- 원칙적으로는 일반 사용자는 이들 작업을 수행할 수 없다. 

#### '종료한다'는 것
- '시스템을 안전하게 종료하고 전원을 끄는 것'을 **셧다운**(shutdown), '재시작 하는 것'을 **리부팅**(rebooting)이라고 한다. Linux는 항상 가동하는 서버로 사용되기 떄문에 이들 작업을 수행하는 것은 긴급 상황이 발생한 경우 뿐이다. 

#### shutdown 명령
- **shutdown** 명령은 종료나 재시작을 수행하는 명령으로, 실행하면 로그인 중인 모든 사용자에게 메시지가 통지되며, 사용하려면 관리자로 로그인 해야 한다. 
```shell
shutdown -h +5 Shutdown At 10:25 # 사용자에게 통지되는 메시지
# shutdown [옵션] [시간설정] [메시지]
# 옵션 -h는 종료, -r은 리부팅
# 시간설정은 now는 지금바로(종료만) +5는 5분 후를 뜻한다. 
```

#### halt 명령
- **halt** 명령도 시스템을 종료하는 명령이다. 
- 사용자에게는 통지나 시간 설정 권한이 없기 때문에, 가급적 shutdown 명령을 사용하도록 한다. 
- 환경에 따라 사용할 수 없는 경우도 있다. 
```shell
halt
```

#### reboot 명령
- **reboot** 명령은 시스템을 다시 시작하는 명령이다. 
- 사용자에게는 통지나 시간 설정 권한이 없기 때문에, 가급적 shutdown 명령을 사용하도록 한다. 
```shell
reboot
```

```ad-attention
- halt 명령과 reboot 명령은 환경에 따라서는 일반 사용자도 이용할 수 있지만, 여러 사용자가 공유하여 사용하는 경우에는 누가 어떤 작업을 하고 있는지 알 수 가 없다. '마음대로 종료해서는 안 된다' 라는 점을 명심하자.
```


### 사용자 환경 설정
#### 닷파일
- 닷 파일은 대부분 시스템 관리용 환경 설정 파일이다. 닷 파일이 `ls` 명령(옵션 없음)으로 표시되지 않는 것은 부주의하게 조작할 수 있는 위험을 방지하기 위해서다.

##### 닷 파일의 예
- 새로 작성한 홈 디렉터리에서 `ls -a`를 실행하면 닷 파일만 표시된다.
```shell
ls -a
```

#### 주요 환경 설정 파일
- 홈 디텍터리 내의 시스템 환경 설정 파일에는 다음과 같은 것이 있다. (bash의 경우)

| 파일명        | 내용                                                                       |
| ------------- | -------------------------------------------------------------------------- |
| .bash_history | bash로 실행한 명령의 이력                                                  |
| .bash_profile | 로그인시에 실행되는 환경 설정                                              |
| .bash_logout  | 로그아웃 시에 실행되는 환경 설정                                           |
| .bashrc       | .bash_profile로부터의 호출이나 쉘 시작 시에 실행되는 환경 설정             |
| .bash_login   | .bash_profile이 없는 경우에 사용되는 로그인 시의 환경 설정                 |
| .profile      | .bash_profile이나 .bash_login이 없는 경우에 사용되는 로그인 시의 환경 설정 |

- 그 외 vi(vim)의 기록 파일(.viminfo) 등 애플리케이션별로 환경 설정 파일이 저장되어 있는 경우도 있다. 

```python
# pseudocode

## 로그인의 경우
def 로그인:
	do .bash_profile
	if not .bash_profile:
		do .bash_login
		if not .bash_login:
			do profile
	do .bashrc

로그인()

################################

# 로그아웃의 경우
def 로그아웃:
	do .bash_logout

로그아웃()
```


### 경로설정
- 환경 설정의 예로 경로(PATH) 설정 방법에 대해 소개한다. 

#### 경로 지나가기 
- 자주 사용하는 명령이 있는 디렉터리 경로를 미리 설정해 두면 명령 이름을 입력만 해도 사용할 수 있다. 
- 이를 '경로를 지나간다' 라고 한다. 

#### 환경변수
- Linux에는 쉘과 명령에서 공통적으로 참조할 수 있는 내장 변수가 있는데, 이것을 **환경 변수**라고 한다. 
- 환경변수는 **env**(ENVironment) 명령으로 확인할 수 있다. 

##### PATH 지정
- 경로를 통하게 하기 위해서는 **PATH** 변수에 디렉터리 경로를 지정해야 한다. 
- .bash_profile 파일에서 'PATH=경로' 라고 지정해 두면 로그인할 떄 PATH 변수가 설정된다. 
- 여러 개의 경로를 설정하는 경우에는 ':'로 연결한다. 

```shell
# .bash_profile 파일
...
PATH=$PATH:$HOME/bin
# 새로운 PATH 변수는 기존의 것이 '홈디렉터리 경로/bin'을 추가한 것이 된다. 
# $PATH → PATH 변수: 이보다 전에 지정한 PATH정보를 나타낸다. 
# $HOME → 홈 디렉터리 경로를 나타낸다. 
```
- 이미 있는 환경변수를 참조할 때는 맨 앞에 `$`를 붙인다.

- .bash_profile 파일 변경을 활성화하려면 다시 로그인하거나 **source** 명령을 실행하여 닷 파일을 다시 읽어 들이도록 한다. 
```shell
source ~/.bash_profile
```

##### 쉘 변수
- 시스템 변수에는 쉡 스크립트 등에서 이용되는 쉘 변수도 있다. 
- 내용은 **set** 명령으로 확인할 수 있다. 
	- set 명령은 환경 변수와 쉘 변수를 나타낸다. 
- 쉘 변수와 환경 변수의 이름이 동일한 경우, 한쪽이 바뀌면 다른 한쪽에도 반영된다. 
	- PATH 변수도 그러한 예 중 하나이다. 


#### cron
- **cron**(Command Run ON)은 스크립트 파일을 자동으로 실행하는 시스템이다. 
- 이 시스템을 사용하면 정기적으로 실행하고 싶은 프로그램(명령어나 스크립트 파일 포함)을 정해진 타이밍에 자동으로 실행 할 수 있다. 
- cron은 설정파일인 `/etc/crontab`과 설정 내용에 따라 명령을 실행하는 `crond`라는 프로그램으로 구성된다. 
	- crond 맨 끝의 d는 daemon(데몬; 수호신)에서 따왔다. 


## Linux GUI 환경
- window나 mac과 같이 창(윈도우)를 이용해 파일이나 애플리케이션을 조작하는 GUI 관리 기능을 **window system**이라고 한다. 
- LInux에서는 X window system에서 발전한 **GNOME(놈), KDE, Xfce** 같은 **통합 데스크톱 환경**으로 발전해 왔다. 

### Wayland란
- **Wayland**는 Linux에서 GUI를 이용하기 위한 시스템 중 하나이다. 
- 쉘이 커널과 사용자 사이의 중개자 역할을 하고 있는데, Wayland 또한 커널과 사용자를 중개하는 역할을 하고 있다. 

- Wayland는 Wayland 컴포지터(compositor)와 Wayland 클라이언트(client)라는 두 개의 프로그램으로 구성되어 있다. 
- 사용자는 Wayland 클라이언트를 통해 Wayland 컴포지터 기능을 사용한다. 
	- 이 때, Wayland 클라이언트와 Wayland 컴포지터가 통신하는 방식을 **Wayland 프로토콜**이라고 한다. 

### 통합 데스크톱 환경
- 윈도 매니저에 데스크톱용 **유틸리티**(도구)를 모아 놓은 것을 **통합 데스크톱 환경**이라고 한다. 
- Linux에는 **GNOME과 KDE**라는 두 개의 유명한 통합 데스크톱 환경이 있다. 
	- GNOME (GNU Network Object Model Environment)은 가장 많이 사용되는 통합 데스크톱 환경이다. 
		- CentOS, Fedora, Ubuntu 등에서 채택되었다. 
		- GNU (GNU is Not UNIX) : UNIX 호환 시스템을 재배포하기 자유로운 형태로 공개, 구축하는 것을 목표로 하는 프로젝트 이다. 
	- KDE (K Desktop Environment)는 그래픽 그리기 방법으로 GNOME과는 다른 방법을 채택한 데스크톱 환경이다. 


### 기본조작
- 텍스트 모드에서 GNOME 시작과 종료를 실행한다. 

#### 텍스트 모드에서 시작 
```shell
systemctl enable gdm.service # GNOME을 시작
```


### 한국어 환경
- UNIX가 **EUC** (한국어의 경우 **EUC-KR**)을 표준으로 한데 비해, Windows는 **CP949**를 표준으로 삼아 왔다. 
- 최근에는 다국어를 나타낼 수 있는 **UTF-8**이라는 문자 코드가 표준으로 사용되고 있다. 
- 지역 설정의 한 예로는 로케일(locale)이 있는데, 한국어를 나타내는 LANG 변수 값은 **ko_KR.UTF-8**이다.
