
#### 여러 가지 쉘
| 이름            | 쉘                                                                                                                                                                                             |
| :---------------: | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| sh <br>(에스에이치) | 가장 기본적인 명령어 처리 능력을 가지고 있는 쉘로, b쉘 이라고 부른다.<br>동작은 빠르지만, 기능 면에서는 다른 쉘에 비해 빈약하기 때문에 주로 쉘 스크립트의 실행 환경 등에 사용되는 경우가 많다. |
| bash <br>(배쉬)     | b쉘을 확장한 쉘로, 현재는 이것을 b쉘이라 부르는 경우도 있다.<br>Linux에서는 표준 쉘로 채택되어 있으며, 가장 널리 알려진 쉘이라 할 수 있다.                                                     |
| ksh <br>(k쉘)       | b쉘을 확장한 쉘로, AT&T사가 개발했으며, 상용 UNIX로 사용되고 있다.                                                                                                                             |
| csh <br>(c쉘)       | 주로 BSD계열에서 채택되고 있는 쉘로, c쉘이라고 부른다. <br>C언어적 명령어 구문을 가지고 있는 것이 특징이다.                                                                                    |
| tcsh <br>(tc쉘)     | c쉘을 확장한 쉘로 현재의 BSD 계열 OS에서는 표준 쉘이다.<br> bash와 함께 많이 사용하는 쉘이다.                                                                                                  |
| zsh <br>(z쉘)       | b쉘을 확장한 쉘이지만, tcsh 기능도 갖고 있다. <br>b쉘 계열과 c쉘의 두 기능을 모두 사용할 수 있지만, 대신 동작이 느린 단점이 있다.                                                                  |

#### 주요 디렉터리
| 디렉터리 | 역할                                                                                          |
| :--------: | --------------------------------------------------------------------------------------------- |
| bin      | 바이너리 형식의 실행 파일이나 명령이 보관되어 있다.                                           |
| dev      | 디바이스 관련 파일이 보관되어 있다.                                                           |
| etc      | 각종 설정 파일 등 다양한 파일이 보관되어 있다.                                                |
| root     | 루트 디렉터리와는 별도로 준비된 시스템 관리자용인 홈 디렉터리이다.                            |
| sbin     | 관리자용 시스템 표준 명령이 보관되어 있다.                                                    |
| usr      | 각 사용자의 데이터나 애플리케이션이 보관되어 있는 장소이다.                                   |
| home     | 이 디렉터리 아래에 사용자별 디렉터리가 만들어지고, <br>거기가 각 사용자의 홈 디렉터리가 된다. |
| var      | 애플리케이션의 기록(로그) 파일이나 메일 데이터 등이 보관되어 있는 장소이다.                   |

#### 파일 시스템의 종류
- Linux에서 사용되는 주요 파일 시스템에 대해 알아본다.

| 파일 시스템 | 특징                                                                                                                                                            |
| ----------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| ext4        | Linux의 표준 파일 시스템으로 채택된 ext(EXTended file system)의 후속이다.<br>현재도 많은 Linux 디스트리뷰션의 디폴트 파일 시스템으로 되어 있다.                 |
| JFS         | IBM이 개발한 파일 시스템이 기반이며, Linux에서는 커널 2.6이 표준으로 채택되었다.<br>기존의 파일 시스템에 비해 신뢰성이 높으며 접속 속도가 빠르다는 특징이 있다. |
| XFS         | SGI사가 개발한 파일 시스템을 이식한 것으로, 병렬 입출력 조작이 뛰어나다.                                                                                        |

- 가상 파일 시스템 
	- 파일이 많은 경우 하드 디스크나 SSD에 저장되지만, 메모리 일부를 파일 시스템으로 사용한 것을 **가상 파일 시스템**이라고 한다. 가상 파일 시스템의 예로는 tmpfs나 devtmpfs와 같은 것들이 있다. 

##### 파일의 압축과 풀기 in Linux
- Linux에서는 크기를 작게 압축하여, 여러 개의 파일로 정리하는 것을 아카이브라고 하여 구별한다. 
- 이때, **아카이브**된 파일을 원래대로 되돌리는 것을 **해제**라고 한다. 
- 그러나, windows에서는 푸는 것을 해제라고 부르고 있어 용어가 혼용되는 경우가 있다. 

- window에서는 ZIP이라는 압축형식이 유명하지만, Linux의 경우는 종류가 많고, 표준 압축 방식에 대해서는 이에 대응한 명령이 준비되어 있다. 

| 주요 명령어   | 기능                                                 |
| :------------: | :--------------------------------------------------: |
| gzip / gunzip | 압축 / 해제                                          |
| zip / unzip   | 압축 / 해제                                          |
| tar           | 아카이브, 생성, 압축, 해제<br>(하나의 명령으로 대응) |

- tar 압축 파일의 경우, 아카이브만 하면 확장자가 `.tar` 인 파일이 만들어지고, 옵션을 사용한 압축까지 한 경우 `.tar.gz`와 같이 두 개의 확장자가 나란히 있는 파일이 만들어진다.

#### 절대경로와 상대경로 
##### 절대경로
- **루트 디렉터리**를 기점으로 지정하는 방법이다. 이 표시 방법은 **커런트 디렉터리**(현재 표시하고 있는 디렉터리)가 어디에 있든 상관없이 확실하게 목적한 파일을 지정할 수 있다. 
	- `/` (root dir)
		- `/`는 경로의 맨 처음이나 단독으로 사용하는 경우 **루트 디렉터리**를 나타낸다. 
```shell
/home/beginner/sample.txt
```

##### 상대경로 
- 커런트 디렉터리를 기점으로 지정하는 방법이다. 아래 그림에서 커런트 디렉터리를 beginner 디렉터리로 했을 경우를 살펴보자.
	- `./..`
		- `'..'`은 하나 위의 디렉터리(부모 디렉터리)를 나타낸다.
	- `.`
		- `'.'`는 커런트 디렉터리를 나타낸다. 
		- 커런트 디렉터리의 상대경로 `'./'`는 생략할 수 있다. 
```shell
# 현재 beginner 라는 폴더에 위치하고, 내부에 sample.txt 라는 파일이 있다.
./sample.txt 
또는 
sample.txt

# home 폴더 아래에 picture과 beginner 라는 이름의 폴더가 있다. 
# 커런트 폴더 -> beginner
./.. => home 폴더
./../picture
```

- 홈 디렉터리를 표시할 때 `'~'` (tilde)로 나타내기도 한다.

### 기본 명령어
#### 디렉터리의 이동과 파일 표시 관련
##### cd
- cd(Change Directory): 디렉터리 이동 
```shell
cd dir_name
# 이때 절대경로, 상대경로 무관

cd 
# 단독으로 쓰이면, 홈 디렉터리로 이동
```

##### pwd
- pwd(Print work Directory): 커런트 디렉터리의 절대 경로를 표시

##### ls
- ls(List directory): 디렉터리 정보를 조사
```shell
# /beginner/data/ 밑에 a, b 폴더와 sample1.txt, sample2.txt 가 있을 때
ls data
>>> a b sample1.txt sample2.txt

# 디렉터리명 또는 파일명을 생략하면 커런트 디렉터리에 대한 내용을 표시
ls 

ls -1 # 상세정보가 나타난다.
ls -a # 숨김파일 (.dot 파일)도 전부 나타낸다. 

```


#### 파일 및 디렉터리 작성/삭제 관련
##### touch
- 파일 생성
```shell
touch test1
touch sample.txt
```
##### mv
- mv(MoVe file): 파일명을 변경하거나 파일을 이동할 때 사용
```shell
# 1. 파일명 변경
# mv [원래이름] [변경후이름]
mv sample1.txt sample

# 2. 파일 이동
# mv [이동하고자하는 파일명] [이동할 디렉터리 경로]
mv sample data
```
- 📌파일명과 같은 이름의 디렉터리가 있는 경우 경로를 올바르게 입력하지 않으면 '파일명 변경' 대신 '파일 이동'이 실행될 수 있으니 주의!

##### cp
- cp(CoPy file): 파일을 복사할 때 사용하는 명령
```shell
# cp [복사하고자 하는 파일명] [복사할 디렉터리 경로]
cp sample3.txt data
```

##### mkdir
- mkdir(MaKe DIRectory): 새로운 디렉터리 생성
```shell
mkdir temp
```

##### rmdir 
- rmdir(ReMove DIRectory): 빈 디렉터리 삭제 명령
```shell
rmdir temp
```

##### rm
- rm(ReMove file): 파일이나 디렉터리 삭제 명령
```shell
rm sample3.txt

# 파일이나 디렉터리가 들어있는 디렉터리(내용 포함)를 삭제하는 옵션
rm -r temp
```

#### 파일 조작 관련
##### cat
- cat(conCATenate): 파일의 내용 열람
```plain
# sample1.txt

I love Linux
```

```shell
$ cat sample1.txt
>>> I love Linux
```

- 파일명을 지정하지 않으면 키보드 입력 대기 상태가 되어 키보드로 입력한 내용을 반복적으로 표시한다. 
```shell
$ cat
>>> test
test
>>> test2
test2
>>>
```
- 입력 대기 해제시에는 `ctrl + c`를 사용한다. 

##### sort
- sort 명려은 지정한 텍스트 파일 내용을 정렬하여 표시한다. 
- 옵션이 없으면 오름차순(알파벳), `-r`을 붙이면 역순(내림차순)으로 정렬한다.

```plain
# cat.txt
kkoma
alex
ran
sham
```

```shell
$ sort cat.txt
alex
kkoma
ran
sham
```

- 이때, 파일명을 지정하지 않으면 키보드 입력 대기 상태가 되고, `ctrl + D` 를 누르면 입력한 내용을 정렬하여 표시한다. (bash의 경우)
	- **쉘에 따라서 로그아웃하는 경우도 있으니 주의!**

```shell
$ sort
>>> dog 
>>> mouse
>>> bird
# 여기서 ctrl + D 를 누르면
bird
dog
mouse
```

##### grep
- grep (Global Regular Expression Print) : 여러 파일 중에서 문자열을 검색하는 명령

```plain
# linenumber1
sinseol-dong
dongdaemun
jongro 5-ga
jongro 3-ga
jonggak
```

```shell
# grep [검색할 문자열(정규표현)] [파일명(경로)]
$ grep jongno linenumber1
>>> jongno 5-ga
>>> jongno 3-ga
```
- 지정한 문자열을 포함한 모든 행이 표시된다.

#### 파일 및 명령을 검색하는 명령관련
##### find
- 파일을 검색하기 위한 명령. 닷 파일도 검색이 가능하다.
- 커런트 디렉터리 이하 모든 폴더와 파일에 대해 검색을 한다.
```shell
find namelist # 파일명 또는 임의의 문자열

# find [검색 시작 디렉터리] [파일명 또는 임의의 문자열]
find data namelsit
```

##### which
- 지정된 명형의 본체를 검색하여 그 절대경로를 표시한다. 
```shell
# which [명령이름]
which ls
>>> /bin/ls # ls 명령의 절대경로가 표시된다.
```

##### whereis
- 명령 경로 뿐만 아니라, 매뉴얼이나 소스코드 파일 등의 경로도 동시에 조사하여 표시한다. 
```shell 
# whereis [명령이름]
whereis ls
```


#### 와일드 카드
##### *
- `find a*` 에서, `'a*'`은 **첫 글자가 a이면 그 후의 문자는 무엇이든 괜찮다**라는 의미
- 임의의 0개 이상의 문자열을 나타냄
##### ?
- 한 개의 문자열
- `find a?` 라는 명령은 **a로 시작하는 두 문자의 문자열을 검색하라**는 의미

- 와일드 카드는 문자열의 전후, 혹은 사이에 껴있어도 가능하다.
	- `*sample`, `pict?data` 등

- 주요 와일드 카드
| 기호           | 기능                              | 표기 예               | 의미                                               |
| :--------------: | :--------------------------------: | :---------------------: | :-------------------------------------------------- |
| [ ]             | [] 안의 임의의 1문자              | `[dog]` <br>`[a-z]`   | d,o,g라는 세개의 문자<br>a부터 z까지의 모든 알파벳 |
| `[^]`<br>`[!]` | []안의 문자열 이외의 임의의 1문자 | `[^dog]` <br>`[!dog]` | d, o, g 이외의 문자                                |
| {}             | {} 안에 지정된 각각의 문자열      | {dog, rat}            | dog, rat 이라는 두개의 문자열                      |


#### vi 실행과 종료
##### vi 실행
```shell
# vi 실행
vi

vi sample1.txt
```
- 파일명을 지정하여 실행할 경우, 기존에 있는 파일명을 지정하면 그 파일을 열고, 새로운 파일명을 지정하면 그 이름의 파일을 새로 만들 수 있다. 지정하지 않으면 파일명이 미정인 신규 파일이 열린다. 

##### vi 종료
- `esc` 키를 누르면 명령모드로 전환되고, 이때 `:q!` 라고 입력하면 파일을 저장하지 않고 vi가 종료된다.

##### vi 모드 변경
- vi에는 실행하는 작업에 따라 세가지 모드가 있다.
- vi명령은 소문자인지, 대문자인지에 따라 동작이 다르므로 주의해야 한다.
![](assets/Linux%20note.png)

- 곤란할 때는 ESC
	- vi를 사용하다가 자신이 어떤 모드에 있는지 알 수 없거나, 편집 작업 등으로 혼란스러운 경우에는 `ESC`키를 누른다. 대부분의 경우에는 명령모드로 돌아갈 수 있으므로 거기서 다시 작업을 진행하자.

#### vi 기본 조작
- vi를 실행하면 새로운 행의 왼쪽 끝에 커서가 표시된다. 
- 신규 작성 팡일의 경우는 화면 왼쪽 상단(첫째 행 첫 문자), <br>기존 파일의 경우는 마지막 행의 다음 행 왼쪽 끝에 표시된다.

##### 인서트 모드로 전환하기 위한 키 정리
| 키  | 모드 변경 후의 상태                                           |
|:---:| ------------------------------------------------------------- |
|  i  | 커서 앞(왼쪽에서부터) 문자를 입력할 수 있다.                  |
|  I  | 커서가 있는 행의 맨 앞에 문자를 입력할 수 있다.               |
|  a  | 커서 다음(오른쪽)부터 문자를 입력할 수 있다.                  |
|  A  | 커서가 있는 행의 끝에서 문자를 입력할 수 있다.                |
|  o  | 커서 한 줄 아래에 행을 삽입하고 그곳에 문자를 입력할 수 있다. |
|  O  | 커서 한 줄 위에 행을 삽입하고 그곳에 문자를 입력할 수 있다.   |

#### 저장과 종료
- ex 모드에서 저장하거나 종료할 때 사용하는 명령어.
- 저장, 종료만 각각 수행하는 명령과 같이 수행하는 명령어로 나뉜다.

| 명령      | 기능                           |
| --------- | ------------------------------ |
| :w        | 저장                           |
| :w 파일명 | 다른 이름으로 저장             |
| :w!       | 강제로 저장                    |
| :q        | 파일을 저장하지 않고 종료      |
| :q!       | 파일을 저장하지 않고 강제 종료 |
| :wq       | 파일을 저장하고 종료           |
| :wq!      | 파일을 강제러 저장하고 종료    |

##### vim에서 실수로 강제 종료되었을 때
- Vim은 편집 중인 데이터를 일시적으로 .swp라는 확장자를 가진 파일에 저장한다. 
- 조작 실수 등으로 Vim을 바르게 종료하지 못한 경우에도 .swp 파일은 삭제되지 않고 남아서, 다음에 같은 이름의 파일을 열 때, .swp 파일을 어떻게 할 지 물어본다. 
- 이 때의 옵션은 `R` (Recover :회복)이나 `E` (Edit anyway :강제편집), `Q`(Quit :종료), `A` (Abort :중단)이 있다. 
- .swp 파일은 find 명령 등으로 찾고, 필요 없을 시 rm 명령으로 삭제한다. 

#### 리다이렉트
- 표준 입력, 표준 출력, 표준 오류 출력의 입출력 대상을 변경하는 것을 **리다이렉트**(또는 **리다이렉션**)라고 한다. 

##### 출력 대상 지정
```shell
명령 > sample1.txt # 출력 대상 경로
```
- 이때, `>`는 저장(덮어쓰기), `>>`는 추가저장을 의미한다. 
	- 오류 출력의 경우는 `2>` 또는 `2>>` 을 의미한다. 

##### 입력 대상의 지정
```shell 
명령 < sample2.txt # 입력 대상의 경로
```

##### 예시
```shell
sort < sample1.txt > sample2.txt
# 이때 sample1 → 정렬 대상이 되는 파일(입력)
# sample2 → 저장할 곳의 경로(출력)
```


#### 파이프란? 
- 명령에 의해 얻은 결과를 다른 명령에 넘겨주고 싶을 때 사용한다.
```shell
ls | more
```
- more : 출력 결과를 페이지 단위로 표시하는 명령
- 파이프는 명령이 세개 이상 있어도 연결할 수 있다.

```shell
ls / | grep sr
# 루트 디렉토리를 조사하는데, 이 때 문자열 'sr'이 포함된 결과를 찾아라 
```


### 파일 관련 명령
##### 텍스트 출력 페이징
- more 명령과 less 명령은 화면(페이지)을 기준으로 출력 결과를 표시(페이징) 한다. 
- 출력 행이 많은 경우 장동으로 스크롤되는 것을 방지할 수 있으며, 이런 명령을 **페이저**라고 한다.

###### more 명령

```plain
# pet.txt 내용
...
kkoma
alex
ran
sham
...
```

```shell
more pet.txt # 파일명

>>>

...
kkoma
alex
ran
sham
--More--
```

- 출력 결과가 화면에 다 표시되지 않은 경우, 1페이지분이 표시된 후 `--More--`이 표시되고, 내부 명령어는 입력 대기 상태가 된다. 이때 사용 가능한 명령어는 아래와 같다.  
	- 스페이스 → 다음 페이지를 표시
	- enter → 1행씩 스크롤
	- h → 도움말
	- q → 종료

###### less 명령
- 내부 명령이 more 보다 강화되어 있어 간단한 검색이나 점프 이동이 가능하다. 
- 끝까지 표시되어도 자동으로 종료되지 않으므로 'q'를 입력하여 종료한다.
```shell
less pet.txt # 파일명

>>>
...
kkoma
alex
ran
sham
...
```
- 이때, 사용 가능한 내부 명령은 다음과 같다. 

###### 내부 명령
| 명령어          | 기능                             |
| :--------------: | -------------------------------- |
| 스페이스 또는 z | 다음 페이지를 표시               |
| w               | 이전 페이지를 표시               |
| Enter           | 1행씩 스크롤                     |
| < 또는 q        | 맨 앞으로 점프                   |
| > 또는 G        | 맨 끝으로 점프                   |
| / 문자열        | 문자열을 앞으로 검색(/로 재검색) |
| ? 문자열        | 문자열을 뒤로 검색 (?로 재검색)  |
| h               | 도움말                           |
| q               | 종료                             |

- 예시
	- 표시 결과가 많을 경우에 less 명령을 파이프 하면 좋다. 
	- `ls -1 /var/log | less`


#### alias 작성하기
- 자주 사용하는 명령의 경우 몇 번이나 같은 인수나 옵션을 입력하는 것은 번거로운 일이다. 
- 이럴 때, alias 명령을 사용하여 옵션이나 인수를 포함한 명령 기술 내용 자체에 대해 별명(alias)을 설정할 수 있다. 

```shell
alias la='ls -a'
# alias 별명='명령문'
# 별명(alias)에는 기존의 명령 이름은 사용할 수 없다.
```

##### alias 목록 표시하기
- 인수나 옵션을 붙이지 않고, alias 명령을 실행하면 현재 이영 가능한 에일리어스를 표시할 수 있다. 
```shell
alias
```

![](assets/Linux%20note-1.png)

##### alias 삭제하기
```shell
unalias la # 별명(alias)
```


#### 링크 작성하기
- ln 명령어(Link) 명령은 파일이나 디렉터리에 대한 **링크(링크 파일)** 을 만든다.
- 링크에는 **심볼릭 링크와 하드 링크** 두 종류가 있다.
```shell
# ln [옵션명] [링크의 참조대상] [링크명]
ln -s /home/beginner/sample1.txt sample
```

- 이때 옵션(-s)이 붙으면 심볼릭 링크, 없으면 하드링크이다.
```shell
ln -s /home/beginner/sample1.txt sample # 심볼릭 링크
ln /home/beginner/sample1.txt sample # 하드 링크
```

##### 심볼릭 링크와 하드 링크
- 심볼릭 링크 → 파일로의 참조
	- 링크를 삭제해도 원래의 파일에는 영향이 없다
	- 본체를 삭제하면 링크가 끊어진다.
- 하드링크 → 파일 실체로의 참조
	- 보통의 파일은 실체와 이름이 1:1 관계이다.
	- 하드링크를 만들면 하나의 파일을 두 개의 이름으로 참조할 수 있다. 

#### 명령 종류 알아보기 
```shell 
type ps
```

- 내부 명령인 경우
![](assets/Linux%20note-2.png)

- 외부 명령인 경우
![](assets/Linux%20note-3.png)

- alias인 경우
![](assets/Linux%20note-4.png)

#### 파일의 타임스탬프 확인/ 변경하기
- 파일에는 갱신 일시나 접속일시가 기록되어 있는데, 이것들을 **stat** 명령으로 알 수 있다. 
![](assets/Linux%20note-5.png)

- touch 명령을 사용하면 파일의 타임스탬프를 변경할 수 있다. 
```shell
touch -md "2023-05-18 12:00:00" abc.txt # vkdlfaud
# m 으로 변경 일시, a로 접속일 시를 변경한다.
# 둘다 지정하지 않으면 양쪽 모두 수정한다. 

# d로 일시를 지정한다. 
# 지정하지 않으면 현재 일시가 된다.
```

- 파일명만 지정해서 실행아면 크기가 0인 빈 파일이 만들어 진다. 
```shell
touch test.py
touch .gitignore
```


#### 메모리와 디스크 명령
- free, df, du 명령은 디폴트로는 결과의 단위가 KB이다. 
- -h 옵션을 붙이면 읽기 쉬운 당위로 표시할 수 있다. 

##### 메모리 사용량 알아보기 
- free 명령을 사용해서 메모리 사용량을 알 수 있고, 스왑(교체) 파일(메모리가 사용하지 않는 부분을 일시적으로 디스크에 옮긴 파일)의 크기도 확인 할 수 있다. 
```shell
free
```

##### 디스크의 사용량 알아보기 
- df 명령을 사용하여 디렉터리와 파일 시스템의 관계와 사용량을 알 수 있다.
```shell
df
``` 

##### 파일 및 디렉터리의 크기 알아보기
- du 명령은 지정한 파일의 크기 및 디렉터리 사용량을 표시하는 명령어 이다.
```shell
du -a diary.txt
# -a → 파일 단위로 크리를 표시
```

- 파일명(또는 디렉터리명)을 지정하지 않은 경우는 커런트 디렉터리 아래의 모든 디렉터리를 조사하여 표시한다. 
```shell
du - a | less

```

![](assets/Linux%20note-6.png)
- 사용량(kb) 와 파일명이 표시된다.

#### 사용자 관련 명령
##### 사용자의 로그인 상황 확인하기
- w 명령은 현재 로그인 중인 사용자와 그 사람이 무엇을 하고 있는지 정보를 표시한다. 
```shell
w
```

- 비슷한 명령어로 who 가 있다. 이는 사용자명롸 로그인 일시를 표시한다. 
```shell
who
```

##### 비밀번호 변경하기
- passwd 명령은 사용자 계정의 비밀번호에 관한 성정을 변경하는 명령이다. 
- 일반 사용자는 자신의 계정만 조작할 수 있다. 
```shell
passwd
```

- 관리자는 모든 사용자의 비밀번호를 리셋할 수 있다. 이 경우는 다음과 같이 사용자 계정을 지정한다.
	- 관리자는 특정 사용자 계정의 비활성화 또는 비밀번호 유효기간을 바꿀 수도 있다.
```shell
passwd mario # 비밀번호를 리셋하고 싶은 사용자 계정
```


#### 명령 이력 알아보기 
- history 명령을 사용하면 과거에 입력한 명령을 표시할 수 있다. 
```shell
history 5 # 표시 건수 (history 명령 포함)
```

![](assets/Linux%20note-7.png)

- 이때 '!' 와 이력번호를 이어서 입력하고 'enter' 키를 누르면 해당 번호에 대응하는 명령을 다시 실행 할 수 있다. 
	- 또는 간편하게 화살표(up/down)을 이용하여 최근  사용한 명령어 부터 다시 불러 올 수 있다. 

#### 입력을 보완하는 기능
- bash 에서는 명령 또는 경로 입력 도중에 `TAB` 키를 누르면 입력할 문자열의 나머지 문자를 보완해 준다.
	- 후보가 2개 이상일 경우 `TAB` 키를 두번 누르면 후보 목록이 표시된다.

### 권한
- 권한이란 파일이나 디렉터리에 때해 사용자나 그룹이 가지는 권리를 말한다. 
- **보호 모드, 허가속성, 액세스 권한**이라고 한다. 
- 세가지 속성
	- 권한에는 읽기, 쓰기, 실행(디렉터리의 이동이나 검색 등도 포함)의 세 가지 속성이 있다. 
- 세가지 사용자 범주
	- User : 파일 소유자(일반적으로는 작성자)
	- Group : User와 같은 그룹의 사용자
	- Other : 그 외의 다른 사용자 

### 권한의 확인
- `ls -1` 또는 `ls -l`
![](assets/Linux%20note-8.png)

![](assets/Linux%20note-9.png)

| 파일 종류 | 의미                   |
| --------- | ---------------------- |
| -         | 일반 파일              |
| d         | 디렉터리               |
| l         | 심볼릭 링크            |
| c         | 캐릭터형 디바이스 파일 |
| b         | 블록형 디바이스 파일   |

- 디바이스 파일?
	- 주변기기에 접속하기 위한 파일이며, 데이터를 다루는 방법에 따라 두 종류로 나뉜다.

| 권한 | 의미                  |
| ---- | --------------------- |
| r    | 읽기 가능 (Readable)  |
| w    | 쓰기 가능 (Writable)  |
| x    | 실행가능 (eXecutable) |
| -    | 불가능 (각 항목 공통) |


#### 권한의 설정
- 모든 파일과 디렉터리에는 초기 상태로 권한이 설정되어 있다. 
- chmod 명령을 사용하면 사용자가 독자적으로 권한을 변경할 수 있다.
```shell
chmod o+w sample.txt
```
![|500](assets/Linux%20note-10.png)

#### 수치를 사용한 권한 설정
| 권한              | 수치 |
| ----------------- | ---- |
| r (읽기 허가)     | 4    |
| w (쓰기 허가)     | 2    |
| x (실행 허가)     | 1    |
| - (허가하지 않음) | 0    |

![](assets/Linux%20note-11.png)

#### 쉘 스크립트
- 쉘에 대한 명령(명령어)를 미리 텍스트 파일에 저장한 것이다.
- 여러 명령을 조합한 일련의 조작을 모아서 실행할 수 있다. 

##### 권한 설정
- 쉘 스크립트 자체로는 명령어들이 모여진 텍스트 파일일 뿐이며, 이를 쉘 스크립트로 기능하기 위해서는 실행 권한을 부여해야 한다. 

```shell
chmod u+x test.sh
```

- 쉘 스크립트 예시
```shell
#! /bin/sh
ls /home
# Ask your name
echo Input your name:
read name
echo "Hello $name"
```

#### Linux의 태스크 처리
- Linux는 여러 태스크(시스템이 수행하는 작업)를 동시에 진행 할 수 있는 **멀티 태스크**를 지원한다. 
- 이때, 하나하나의 태스크를 **프로세스**라고도 하며, Linux환경에서는 OS가 관리하는 단위로 프로세스가 사용되고 있다. 

##### 잡(jobs)
- 파이프로 명령어끼리 연결한 경우 등 하나 이상의 명령(프로세스) 모임을 **잡** 이라고 한다. 잡과 푸로세스는 각각의 고유한 번호를 가지고 있다. 

#### PS
- ps(Process Status) 명령은 현재 가동 중인 프로세스를 ID번호를 붙여 목록으로 표시한다. 
```shell
ps
```

![](assets/Linux%20note-12.png)

#### jobs 명령 
- jobs 명령은 현재 가동 중인 작업을 번호를 붙여 목록으로 표시한다. 

#### kill 명령어 
- 어떤 이유로든 종료하지 못하고 남아 있는 프로세스 또는 잡을 종료하려면 **kill** 명령을 사용한다. 
	- 일반 사용자는 자신이 실행한 프로세스만을 종료할 수 있다. 
```shell
kill 2444 # 프로세스 ID 또는 잡 번호
kill -9 프로세스 ID # 강제 종료시
```


#### 잡 중단과 재개 
- 실행 중인 잡을 일시 중단, 재개 할 수 있다. 중단하려면 `ctrl+z` 를 누른다,
- Vim에서 diary.txt 를 편집하는 도중에 `ctrl+z`를 누르면 잡이 중단되는데, 
- 이때 재개하여면 **fg**(fore ground) 명령으로 잡 번호를 지정하여 실행한다.
	- 잡 번호를 지정하지 않으면 가장 새로운 잡을 재개한다. 


#### 온라인 매뉴얼 참조
- man(MANual) + 명령어
- 해당 명령어의 매뉴얼이 출력된다(기본 less 옵션)
- space로 다음 페이지로 전환, q로 중도에 종료할 수 있다. 
```shell
man ls
```


### 시스템 관리자
#### 사용자의 종류
- Linux 서용자는 크게 관리자와 일반 사용자로 나뉜다. 관리자를 **슈퍼 유저**라고 하며, 계정명은 **root**가 된다. 이 외에 새로 사용자를 만들경우 일반 사용자로 등록되며, 관리자와는 구별된다. 
- Linux에서는 관리자 권한을 가진 계정은 root 하나 뿐이다. 

