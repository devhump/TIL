---
tags: [Algorithm, python]
---

## 02. 우선순위에 따라 데이터를 꺼내는 자료구조

### 목차
```ad-note
- [[#02. 우선순위에 따라 데이터를 꺼내는 자료구조#우선순위 큐(Priority Queue)|우선순위 큐(Priority Queue)]]
- [[#02. 우선순위에 따라 데이터를 꺼내는 자료구조#힙(Heap)의 특징|힙(Heap)의 특징]]
- [[#02. 우선순위에 따라 데이터를 꺼내는 자료구조#완전 이진 트리 (Complete Binary Tree)|완전 이진 트리 (Complete Binary Tree)]]
- [[#02. 우선순위에 따라 데이터를 꺼내는 자료구조#최소 힙 구성 함수: Min-Heapify()|최소 힙 구성 함수: Min-Heapify()]]
- [[#02. 우선순위에 따라 데이터를 꺼내는 자료구조#힙에 새로운 원소가 삽입될 때|힙에 새로운 원소가 삽입될 때]]
- [[#02. 우선순위에 따라 데이터를 꺼내는 자료구조#힙에서 원소가 제거될 때|힙에서 원소가 제거될 때]]
- [[#02. 우선순위에 따라 데이터를 꺼내는 자료구조#힙 자료구조:  코드구현|힙 자료구조:  코드구현]]
```


### 우선순위 큐(Priority Queue)

- 우선순위 큐는 ***우선순위가 가장 높은 데이터를 가장 먼저 삭제하는 자료구조*** 입니다.
- 우선순위 큐는 데이터를 우선순위에 따라 처리하고 싶을 때 사용합니다.
- 예시) 물건 데이터를 자료구조에 넣었다가 가치가 높은 물건부터 꺼내서 확인해야 하는 경우

| 자료구조                     | 추출되는 데이터             |
| ---------------------------- | --------------------------- |
| 스택 (Stack)                 | 가장 나중에 삽입된 데이터   |
| 큐 (Queue)                   | 가장 먼저 삽입된 데이터     |
| 우선순위 큐 (Priority Queue) | 가장 우선순위가 높은 데이터 |


- 우선순위 큐를 구현하는 방법은 다양합니다. 
	1) 단순히 리스트를 이용하여 구현할 수 있습니다.
	2) 힙(heap)을 이용하여 구현할 수 있습니다. 

- 데이터의 개수가 N개일 때, 구현 방식에 따라서 시간 복잡도를 비교한 내용은 다음과 같습니다. 

| 우선순위 큐 구현 방식 | 삽입시간   | 삭제시간   |
| --------------------- | ---------- | ---------- |
| 리스트                | `O(1)`     | `O (N)`    |
| 힙 (Heap)             | `O (logN)` | `O (logN)` |

- ✔ 위 표에서 리스트의 경우 삽입은 그냥 추가만 하면 되지만, 삭제의 경우 우선순위가 높은 데이터인지를 일일히 확인한 후 삭제해야 하기 때문에 `O(N)`의 시간 복잡도를 가짐
- 단순히 N개의 데이터를 힙에 넣었다가 모두 꺼내는 작업은 정렬과 동일합니다. (힙 정렬)
- 이 경우 시간 복잡도는 `O(NlogN)`입니다.



### 힙(Heap)의 특징
- 힙은 완전 이진 트리 자료구조의 일종입니다. 
- 힙에서 항상 루트 노드(root node)를 제거합니다.

![](assets/02.%20Priority%20Queue.png)

- **최소 힙(min heap)**
	- 루트 노드가 가장 작은 값을 가집니다.
	- 따라서 값이 작은 데이터가 우선적으로 제거됩니다.
- **최대 힙(max heap)**
	- 루트 노드가 가장 큰 값을 가집니다. 
	- 따라서 값이 큰 데이터가 우선적으로 제거됩니다. 



### 완전 이진 트리 (Complete Binary Tree)
- **완전 이진 트리**란 루트(root) 노드부터 시작하여 왼쪽 자식 노드, 오른쪽 자식 노드 순서대로 데이터가 차례대로 삽입되는 트리(tree)를 의미합니다. 
![](assets/02.%20Priority%20Queue-1.png)

### 최소 힙 구성 함수: Min-Heapify()
- (상향식) 부모 노드로 거슬러 올라가며, 부모보다 자신의 값이 더 작은 경우에 위치를 교체합니다. 
![](assets/02.%20Priority%20Queue-2.png)

### 힙에 새로운 원소가 삽입될 때
- 새로운 원소가 삽입되었을 때 **O(logN)** 의 시간 복잡도로 힙 성질을 유지할 수 있습니다. 
![](assets/02.%20Priority%20Queue-3.png)

![](assets/02.%20Priority%20Queue-4.png)

![](assets/02.%20Priority%20Queue-5.png)


### 힙에서 원소가 제거될 때
- 원소가 제거되었을 때 **O(logN)** 의 시간 복잡도로 힙 성질을 유지하도록 할 수 있습니다. 
	- 원소를 제거할 때는 가장 마지막 노드가 루트 노드의 위치에 오로록 합니다. 
	- ![](assets/02.%20Priority%20Queue-6.png)
	- 이후에 루트 노드에서부터 하향식으로(더 작은 자식 노드로) Heapify()를 진행합니다. 
	- ![](assets/02.%20Priority%20Queue-7.png)

	- ![](assets/02.%20Priority%20Queue-8.png)


### 힙 자료구조:  코드구현
```python
import sys
import heapq
input = sys.stdin.readline

def heapsort(iterable):
    h = []
    result = []
    # 모든 원소를 차례대로 힙에 삽입
    for value in iterable:
        heapq.heappush(h, value)
        # 힙에 삽입된 모든 원소를 차례대로 꺼내어 담기
    for i in range(len(h)):
        result.append(heapq.heappop(h))
    return result

n = int(input())
arr = []

for i in range(n):
    arr.append(int(input()))

res = heapsort(arr)

for i in range(n):
    print(res[i]) # 오름차순 정렬된 결과가 출력됨
```

- 프로그래밍 언어마다 기본적으로 제공하는 heap 라이브러리가 최소힙인지, 최대힙인지 다름.
- 파이썬의 경우 최소 힙(min-heap) 형태로 동작함.
- 파이썬에서 최대 힙(max-heap)을 구현하기 위해서는 데이터를 넣고, 꺼낼 때, `-` 를 붙여서

- [유튜브 강의 링크](https://youtu.be/AjFlp951nz0)
