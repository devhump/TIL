---
tags: [Algorithm, python]
---

## 25. 자주 사용되는 기타 알고리즘: 투 포인터와 구간 합


### 목차
```ad-note
- [[#25. 자주 사용되는 기타 알고리즘: 투 포인터와 구간 합#투 포인터 (Two Pointer)|투 포인터 (Two Pointer)]]
	- [[#투 포인터 (Two Pointer)#특정한 합을 가지는 부분 연속 수열 찾기: 문제 설명|특정한 합을 가지는 부분 연속 수열 찾기: 문제 설명]]
	- [[#투 포인터 (Two Pointer)#특정한 합을 가지는 부분 연속 수열 찾기: 문제 해결 아이디어|특정한 합을 가지는 부분 연속 수열 찾기: 문제 해결 아이디어]]
	- [[#투 포인터 (Two Pointer)#특정한 합을 가지는 부분 연속 수열 찾기: 코드 예시|특정한 합을 가지는 부분 연속 수열 찾기: 코드 예시]]
- [[#25. 자주 사용되는 기타 알고리즘: 투 포인터와 구간 합#구간 합(Interval Sum)|구간 합(Interval Sum)]]
	- [[#구간 합(Interval Sum)#구간 합 빠르게 계산하기: 문제 설명|구간 합 빠르게 계산하기: 문제 설명]]
	- [[#구간 합(Interval Sum)#구간 합 빠르게 계산하기: 코드 예시|구간 합 빠르게 계산하기: 코드 예시]]
```



### 투 포인터 (Two Pointer)
- **투 포인터 알고리즘**은 <u>리스트에 순차적으로 접급해야 할 때 두 개의 점의 위치를 기록하면서 처리</u>하는 알고리즘을 의미합니다. 
- 흔히 `2, 3, 4, 5, 6, 7` 번 학생을 지목해야 할 때 간단히 <u>'2번부터 7번까지의 학생'</u>이라고 부르곤 합니다. 
- 리스트에 담긴 데이터에 순차적으로 접근해야 할 때는 **시작점**과 **끝점** 2개의 점으로 접근할 데이터의 범위를 표현할 수 있습니다. 

#### 특정한 합을 가지는 부분 연속 수열 찾기: 문제 설명
- $N$개의 자연수로 구성된 수열이 있습니다. 
- **합이 M인 부분 연속 수열의 개수**를 구해보세요.
- 수행 시간 제한은 $O(N)$입니다. 

![](25.%20%20Two%20Pointer-11.png)

- 완전탐색을 이용해 문제를 해결할 수도 있지만, 이 경우 $O(N^2)$ 만큼의 시간이 걸림 → 시간 제한에 걸림

#### 특정한 합을 가지는 부분 연속 수열 찾기: 문제 해결 아이디어 
- <u>투 포인터를 활용</u>하여 다음과 같은 **알고리즘**으로 문제를 해결할 수 있습니다. 
	1. 시작점($start$)과 끝점($end$)이 첫 번째 원소의 인덱스(0)을 가리키도록 한다.
	2. 현재 부분 합이 $M$과 같다면, 카운트한다.
	3. 현재 부분 합이 $M$보다 작다면 $end$를 1 증가시킨다. 
	4. 현재 부분 합이 $M$보다 크거나 작다면, $start$를 1 증가시킨다. 
	5. 모든 경우를 확인할 때까지 2번부터 4번까지의 과정을 반복한다. 

![](25.%20%20Two%20Pointer.png)

- ==$M = 5$==

##### 초기 단계.
- 시작점과 끝점이 첫 번째 원소의 인덱스를 가리키도록 합니다. 
	- 현재의 부분합은 1이므로 무시합니다. 
	- **현재 카운트**: 0
![](25.%20%20Two%20Pointer-12.png)

##### Step 1.
- 이전 단계에서의 부분합이 1이었기 때문에 $end$를 1 증가시킵니다. 
	- 현재의 부분합은 3이므로 무시합니다. 
	- **현재 카운트**: 0
![](25.%20%20Two%20Pointer-13.png)

##### Step 2.
- 이전 단계에서의 부분합이 3이었기 때문에 $end$를 1 증가시킵니다. 
	- 현재의 부분합은 6이므로 무시합니다. 
	- **현재 카운트**: 0
![](25.%20%20Two%20Pointer-14.png)

##### Step 3.
- 이전 단계에서의 부분합이 6이었기 때문에 $start$를 1 증가시킵니다. 
	- 현재의 부분합은 5이므로 카운트를 증가시킵니다. 
	- **현재 카운트**: 1
![](25.%20%20Two%20Pointer-15.png)

##### Step 4.
- 이전 단계에서의 부분합이 5이었기 때문에 $start$를 1 증가시킵니다. 
	- 현재의 부분합은 3이므로 무시합니다.
	- **현재 카운트**: 1

![](25.%20%20Two%20Pointer-16.png)

##### Step 5.
- 이전 단계에서의 부분합이 3이었기 때문에 $end$를 1 증가시킵니다. 
	- 현재의 부분합은 5이므로 카운트를 증가시킵니다.
	- **현재 카운트**: 2
![](25.%20%20Two%20Pointer-17.png)

##### Step 6.
- 이전 단계에서의 부분합이 5이었기 때문에 $start$를 1 증가시킵니다. 
	- 현재의 부분합은 2이므로 무시합니다.
	- **현재 카운트**: 2
![](25.%20%20Two%20Pointer-18.png)

##### Step 7.
- 이전 단계에서의 부분합이 2이었기 때문에 $end$를 1 증가시킵니다. 
	- 현재의 부분합은 7이므로 무시합니다.
	- **현재 카운트**: 2
![](25.%20%20Two%20Pointer-19.png)

##### Step 8.
- 이전 단계에서의 부분합이 7이었기 때문에 $start$를 1 증가시킵니다. 
	- 현재의 부분합은 5이므로 카운트를 증가시킵니다.
	- **현재 카운트**: 3
![](25.%20%20Two%20Pointer-20.png)

#### 특정한 합을 가지는 부분 연속 수열 찾기: 코드 예시
```python
n = 5 # 데이터의 개수 N
m = 5 # 찾고자 하는 부분합 M
data = [1, 2, 3, 2, 5] # 전체 수열

count = 0
interval_sum = 0
end = 0

# start를 차례대로 증가시키며 반복
for start in range(n):
	while interval_sum < m and end < n:
		interval_sum += data[end]
		end += 1
	# 부분합이 m일 때 카운트 증가
	if interval_sum == m:
		count += 1
	interval_sum -= data[start]

print(count)
## 실행결과
# 3
```


### 구간 합(Interval Sum)
- **구간 합 문제**: 연속적으로 나열된 $N$개의 수가 있을 때 <u>특정 구간의 모든 수를 합한 값을 계산</u>하는 문제
- 예를 들어 5개의 데이터로 구성된 수열 $\{10, 20, 30, 40, 50\}$이 있다고 가정합시다.
	- 두 번째 수부터 네 번째 수까지의 합은 $20 + 30 + 40 = 90$입니다.

#### 구간 합 빠르게 계산하기: 문제 설명
- $N$개의 정수로 구성된 수열이 있습니다. 
- $M$개의 쿼리(Query) 정보가 주어집니다.
	- 각 쿼리는 $Left$와 $Right$로 구성됩니다. 
	- 각 쿼리에 대하여 $[Left, Right]$구간에 포함된 데이터들의 합을 출력해야 합니다. 
- 수행 시간 제한은 $O(N + M)$입니다.

![](25.%20%20Two%20Pointer-21.png)

#### 구간 합 빠르게 계산하기: 코드 예시
```python
# 데이터의 개수 N과 데이터 입력 받기
n = 5
data = [10, 20, 30, 40, 50]

# 접두사 합(Prefix Sum) 배열 계산
sum_value = 0
prefix_sum = [0]
for i in data:
	sum_value += i
	prefix_sum.append(sum_value)
	
# 구간 합 계산(세 번째 수부터 네 번째 수까지)
left = 3
right = 4
print(prefix_sum[right] - prefix_sum[left - 1])
# 70
```

