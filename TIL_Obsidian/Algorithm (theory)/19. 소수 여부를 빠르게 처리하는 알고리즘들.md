---
tags: [Algorithm, python]
---

## 19. 소수 여부를 빠르게 처리하는 알고리즘들(Algorithms judging Prime Number)

### 목차
```ad-note
- [[#19. 소수 여부를 빠르게 처리하는 알고리즘들(Algorithms judging Prime Number)#소수 (Prime Number)|소수 (Prime Number)]]
- [[#19. 소수 여부를 빠르게 처리하는 알고리즘들(Algorithms judging Prime Number)#소수의 판별: 기본적인 알고리즘|소수의 판별: 기본적인 알고리즘]]
	- [[#소수의 판별: 기본적인 알고리즘#소수의 판별: 기본적인 알고리즘 성능 분석|소수의 판별: 기본적인 알고리즘 성능 분석]]
- [[#19. 소수 여부를 빠르게 처리하는 알고리즘들(Algorithms judging Prime Number)#약수의 성질|약수의 성질]]
- [[#19. 소수 여부를 빠르게 처리하는 알고리즘들(Algorithms judging Prime Number)#소수의 판별: 개선된 알고리즘|소수의 판별: 개선된 알고리즘]]
	- [[#소수의 판별: 개선된 알고리즘#소수의 판별: 개선된 알고리즘 성능 분석|소수의 판별: 개선된 알고리즘 성능 분석]]
- [[#19. 소수 여부를 빠르게 처리하는 알고리즘들(Algorithms judging Prime Number)#다수의 소수 판별|다수의 소수 판별]]
- [[#19. 소수 여부를 빠르게 처리하는 알고리즘들(Algorithms judging Prime Number)#에라토스테네스의 체 알고리즘|에라토스테네스의 체 알고리즘]]
	- [[#에라토스테네스의 체 알고리즘#에라토스테네스의 체 알고리즘 동작 예시|에라토스테네스의 체 알고리즘 동작 예시]]
	- [[#에라토스테네스의 체 알고리즘#에라토스테네스의 체 알고리즘: 코드구현|에라토스테네스의 체 알고리즘: 코드구현]]
	- [[#에라토스테네스의 체 알고리즘#에라토스테네스의 체 알고리즘 성능 분석|에라토스테네스의 체 알고리즘 성능 분석]]
```


### 소수 (Prime Number)
- **소수**란 <u>1보다 큰 자연수 중에서 1과 자기 자신을 제외한 자연수로는 나누어 떨어지지 않는 자연수</u> 입니다. 
	- **6**은 1, 2, 3, 6으로 나누어 떨어지므로 소수가 아닙니다. 
	- **7**은 1과 7을 제외하고는 나누어 떨어지지 않으므로 소수입니다. 
- 코딩 테스트에서는 어떠한 자연수가 소수인지 아닌지 판별해야 하는 문제가 자주 출제됩니다. 

### 소수의 판별: 기본적인 알고리즘
```python
# 소수 판별 함수(2이상의 자연수에 대하여)
def is_prime_number(x):
	# 2부터 (x-1)까지의 모든 수를 확인하며
	for i in range(2, x):
		# x가 해당 수로 나누어 떨어진다면
		if x % i == 0:
			return False # 소수가 아님
	 return True # 소수임

print(is_prime_number(4)) # False
print(is_prime_number(7)) # True

```

#### 소수의 판별: 기본적인 알고리즘 성능 분석
- 2부터 $X-1$까지의 모든 자연수에 대하여 연산을 수행해야 합니다. 
	- 모든 수를 하나씩 확인한다는 점에서 시간 복잡도는 $O(X)$입니다. 
		- 👉 숫자가 커지면 커질 수록 선형적으로 시간 복잡도가 증가한다.


### 약수의 성질 
- **모든 약수가 가운데 약수를 기준으로 곱셈 연산에 대해 대칭**을 이루는 것을 알 수 있습니다. 
	- 예를 들어 16의 약수는 1, 2, 4, 8, 16입니다.
	- 이때 $2 \times 8 = 16$은  $8 \times 2 = 16$과 대칭입니다. 
- 따라서 우리는 특정한 자연수의 모든 약수를 찾을 때 **가운데 약수(제곱근)까지만 확인**하면 됩니다. 
	- 예를 들어 16이 2로 나누어 떨어진다는 것은 8로도 나누어 떨어진다는 것을 의미합니다. 

![](19.%20Algorithms%20judging%20Prime%20Number_.png)


### 소수의 판별: 개선된 알고리즘
```python
import math

# 소수 판별 함수 (2이상의 자연수에 대하여)
def is_prime_number(x):
	# 2부터 x의 제곱근까지의 모든 수를 확인하며
	for i in range(2, int(math.sqrt(x)) + 1):
		# x가 해당 수로 나누어 떨어진다면
		if x % i == 0:
			return False # 소수가 아님
	return True # 소수임

print(is_prime_number(4)) # False
print(is_prime_number(7)) # True
```
- 👉 파이썬은 기본적으로 거듭 제곱 연산을 지원하기 때문에 제곱근을 위해 `math` 라이브러리를 사용하지 않아도 괜찮지만,  C++와 Java 코드와의 통일성을 위해 유사하게 구성함

#### 소수의 판별: 개선된 알고리즘 성능 분석
- 2부터 $X$의 제곱근(소수점 이하 무시)까지의 모든 자연수에 대하여 연산을 수행해야 합니다. 
	- 시간 복잡도는 $O(N^\frac{1}{2})$입니다.

### 다수의 소수 판별
- 하나의 수에 대해서 소수인지 아닌지 판별하는 방법을 알아보았습니다.
- 하지만 <u>특정한 수의 범위 안에 존재하는 모든 소수</u>를 찾아야 할 때는 어떻게 할까요?
	- **에라토스테네스의 체 알고리즘**을 사용할 수 있습니다. 


### 에라토스테네스의 체 알고리즘
- <u>다수의 자연수에 대하여 소수 여부를 판별</u>할 때 사용하는 대표적인 알고리즘입니다. 
- 에라토스테네스의 체는 $N$보다 작거나 같은 모든 소수를 찾을 때 사용할 수 있습니다. 
- 에라토스테네스의 체 알고리즘의 **구체적인 동작 과정**은 다음과 같습니다. 
	1. $2$부터 $N$까지의 모든 자연수를 나열한다. 
	2. 남은 수 중에서 아직 처리하지 않은 가장 작은 수 $i$를 찾는다.
		- 👉 이때 $i$는 소수를 의미한다.
	3. 남은 수 중에서 $i$의 배수를 모두 제거한다. ($i$는 제거하지 않는다. )
	4. 더 이상 반복할 수 없을 때 까지 2번과 3번의 과정을 반복한다. 


#### 에라토스테네스의 체 알고리즘 동작 예시 
##### 초기단계.
- 2부터 26까지의 모든 자연수를 나열합니다. ($N = 26$)
![](19.%20Algorithms%20judging%20Prime%20Number_-1.png)

##### Step 1. 
- 아직 처리하지 않은 가장 작은 수 2를 제외한 2의 배수는 모두 제거합니다. 
![](19.%20Algorithms%20judging%20Prime%20Number_-2.png)

##### Step 2. 
- 아직 처리하지 않은 가장 작은 수 3를 제외한 3의 배수는 모두 제거합니다. 
![](19.%20Algorithms%20judging%20Prime%20Number_-3.png)

##### Step 3. 
- 아직 처리하지 않은 가장 작은 수 5를 제외한 5의 배수는 모두 제거합니다. 
![](19.%20Algorithms%20judging%20Prime%20Number_-4.png)

##### Step 4. 
- 마찬가지의 과정을 반복했을 때 최종적인 결과는 다음과 같습니다. 
![](19.%20Algorithms%20judging%20Prime%20Number_-4.png)

```ad-hint
- **약수의 성질**을 이용하기
	- 👉최대값(N)이 26이기 때문에, 제곱근의 성질을 이용했을 때, 5 또는 6까지만 확인을 해도 동일한 결과를 나타낼 수 있다.  
```

#### 에라토스테네스의 체 알고리즘: 코드구현
```python
import math

n = 1000 # 2부터 1,000까지의 모든 수에 대하여 소수 판별
# 처음엔 모든 수가 소수(True)인 것으로 초기화(0과 1은 제외)
array = [True for i in range(n + 1)]

# 에라토스테네스의 체 알고리즘 수행
# 2부터 n의 제곱근까지의 모든 수를 확인하며
for i in range(2, int(math.sqrt(n)) + 1):
	if array[i] == True: # i가 소수인 경우(남은 수인 경우)
		# i를 제외한 i의 모든 배수를 지우기
		j = 2 # 이때 j는 배수값을 나타냄
		while i * j <= n:
			array[i * j] = False
			j += 1

# 모든 소수 출력
for i in range(2, n + 1):
	if array[i]:
		print(i, end=' ')
```

#### 에라토스테네스의 체 알고리즘 성능 분석
- 에라토스테네스의 체 알고리즘의 시간 복잡도는 사실상 선형 시간에 가까울 정도로 매우 빠릅니다. 
	- 시간 복잡도는 $O(NloglogN)$입니다. 
- 에라토스테네스의 체 알고리즘은 다수의 소수를 찾아야 하는 문제에서 효과적으로 사용될 수 있습니다. 
	- 하지만 각 자연수에 대한 소수 여부를 저장해야 하므로 **메모리가 많이 필요**합니다.

 ```ad-question
 - **10억**이 소수인지 아닌지 판별해야 할 때 에라토스테네스의 체를 사용할 수 있을까요?
```

- '에라토스테네스의 체 알고리즘'을 이용해 10억의 소수 여부를 판별하기 위해서는 <u>1에서 10억 까지의 테이블이 필요하다.</u>
	- 👉 경우에 따라서 매우 비효율적으로 동작할 수도 있다!
