
### 목차
```ad-note
- [[#선택 정렬|선택 정렬]]
	- [[#선택 정렬#선택 정렬 동작 예시|선택 정렬 동작 예시]]
	- [[#선택 정렬#선택 정렬 소스코드 (Python)|선택 정렬 소스코드 (Python)]]
	- [[#선택 정렬#선택 정렬의 시간 복잡도|선택 정렬의 시간 복잡도]]
- [[#삽입 정렬|삽입 정렬]]
	- [[#삽입 정렬#삽입 정렬 동작 예시|삽입 정렬 동작 예시]]
	- [[#삽입 정렬#삽입 정렬 소스코드 (Python)|삽입 정렬 소스코드 (Python)]]
	- [[#삽입 정렬#삽입 정렬의 시간 복잡도|삽입 정렬의 시간 복잡도]]
```


- **정렬(Sorting)** 이란 <u>데이터를 특정한 기준에 따라 순서대로 나열하는 것</u>을 말합니다. 
- 일반적으로 문제 상황[^정렬이 필요한 예시]에 따라서 적절한 정렬 알고리즘이 공식처러 사용됩니다.

```ad-question
- 여러 개의 데이터(카드)를 어떻게 정렬할 수 있을까요?

![](assets/05.%20sorting_Algorithm-img-%20(1).png)
```

[^정렬이 필요한 예시]: 1. 데이터의 개수가 적을 때, 2. 데이터가 많지만, 범위가 특정되어 있을 때, 3. 이미 데이터가 거의 정렬되어 있는 경우


### 선택 정렬
- 처리되지 않은 데이터 중에서 **가장 작은 데이터를 ==선택==해 맨 앞에 있는 데이터와 바꾸는 것을 반복**합니다.
	- 매번 현재 범위중 가장 작은 수를 확인

#### 선택 정렬 동작 예시

##### Step 0.
- 정렬할 데이터를 준비합니다.
![](assets/05.%20sorting_Algorithm-img-%20(1).png)

##### Step 1.
- 처리되지 않은 데이터 중 가장 작은 '0'을 선택해 가장 앞의 '7'과 바꿉니다. 
![](assets/05.%20sorting_Algorithm-img-%20(3).png)

##### Step 2.
- 처리되지 않은 데이터 중 가장 작은 '1'을 선택해 가장 앞의 '5'와 바꿉니다.
![](assets/05.%20sorting_Algorithm-img-%20(4).png)

##### Step 3.
- 처리 되지 않은 데이터 중 가장 작은 '2'를 선택해 가장 앞의 '9'와 바꿉니다.
![](assets/05.%20sorting_Algorithm-img-%20(6).png)

##### Step 4.
- 처리되지 않는 데이터 중 가장 작은 '3'을 선택해 가장 앞의 '7'과 바꿉니다.
![](assets/05.%20sorting_Algorithm-img-%20(7).png)

##### Step 5.
- 이러한 과정을 반복하면 다음과 같이 정렬이 완료됩니다. 
![](assets/05.%20sorting_Algorithm-img-%20(8).png)
- 👉 마지막 데이터는 위치를 바꿔도 제자리(마지막)이기 때문에, 정렬을 생략해도 된다
- 탐색 범위는 매번 줄어듬
	- 매회 선형 탐색 → 이중 반복문 이용

#### 선택 정렬 소스코드 (Python)

```python
array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

# 여기서 i는 매번 바꾸고자 하는 앞쪽의 위치(인덱스)
for i in range(len(array)): 
	min_index = i # 가장 작은 원소의 인덱스
	for j in range(i + 1, len(array)):
		if array[min_index] > array[j]:
			min_index = j
	array[i], array[min_index] = array[min_index], array[i] # 스와프

print(array)
# [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]	
```


#### 선택 정렬의 시간 복잡도
- 선택 정렬은 N번 만큼 가장 작은 수를 찾아서 맨 앞으로 보내야 합니다. 
- 구현 방식에 따라서 사소한 오차는 있을 수 있지만, 전체 연산 횟수는 다음과 같습니다. 
$$N + (N - 1) + (N - 2) +  \dots  + 2$$
- 이는 $(N^2 + N - 2) / 2$ 로 표현할 수 있는데, 빅오 표기법에 따라서 $O(N^2)$ 이라고 작성합니다.
	- 등차수열 형태 → $O(N^2)$


---

### 삽입 정렬
- 처리되지 않은 데이터를 하나씩 골라 **적절한 위치에 ==삽입==** 합니다.
- 선택 정렬에 비해 구현 난이도가 높은 편이지만, 일반적으로 더 효율적으로 동작합니다. 

#### 삽입 정렬 동작 예시
##### Step 0.
- 첫 번째 데이터 '7'은 그 자체로 정렬이 되어 있다고 판단하고, 두 번째 데이터인 '5'가 어떤 위치로 들어갈지 판단합니다. '7'의 왼쪽으로 들어가거나 오른쪽으로 들어가거나 두 경우만 존재합니다. 

![](assets/05.%20sorting_Algorithm-img-%20(9).png)
- \*참고 :정렬 알고리즘은 기본적으로 왼쪽에서 오른쪽으로 (→) 오름차순을 전제로 하고 이뤄진다. 

##### Step 1.
- 이어서 '9' 어떤 위치로 들어갈지 판단합니다.
![](assets/05.%20sorting_Algorithm-img-%20(10).png)
- 👉 9는 7보다 크므로 움직이지 않는다!

##### Step 2.
이어서 '0'이 어떤 위치로 들어갈지 판단합니다.
![](assets/05.%20sorting_Algorithm-img-%20(11).png)
- 👉 0은 좌측에 있는 요소들 한번씩 확인 하면서 위치를 변경!


##### Step 3.
- 이어서 '3'이 어떤 위치로 들어갈지 판단합니다.
![](assets/05.%20sorting_Algorithm-img-%20(12).png)

##### Step 4.
- 이러한 과정을 반복하면 다음과 같이 정렬이 완료됩니다.
![](assets/05.%20sorting_Algorithm-img-%20(13).png)

#### 삽입 정렬 소스코드 (Python)
```python
array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

for i in range(1, len(array)): # 첫번째 7은 skip, 정렬되어 있다고 가정
	# 여기서 j는 삽입하고자 하는 그 위치를 의미
	for j in range(i, 0, -1): # 인덱스 i부터 1까지 1씩 감소하며 반복하는 문법
		if array[j] < array[j - 1]: # 한 칸씩 왼쪽으로 이동
			array[j], array[j - 1] = array[j - 1], array[j]
		else: # 자기보다 작은 데이터를 만나면 그 위치에서 멈춤
			break

print(array)
# [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```
- 👉 두번째 데이터~ 마지막 데이터까지 위치를 변경 시키며 정렬 진행


#### 삽입 정렬의 시간 복잡도 
- 삽입 정렬의 시간 복잡도는 $O(N^2)$ 이며, 선택 정렬과 마찬가지로 반복문이 두 번 중첩되어 사용 됩니다. 
	- 시간 복잡도의 경우, 반복문 내 추가 적인 로직을 구성해서 달라질 수 있으나, 현재 코드 기준으로는 $O(N^2)$임.
	- 현재 코드는 **단순 이중 반복문 내 비교 연산 & 스와핑 기법**을 이용 
- 삽입 정렬은 <u>현재 리스트의 데이터가 거의 정렬되어 있는 상태라면 매우 빠르게 동작</u>합니다. 
	- 최선의 경우 $O(N)$의 시간 복잡도를 가집니다. 

```ad-question
- 이미 정렬되어 있는 상태에서 다시 삽입 정렬을 수행하면 어떻게 될까요?
![](assets/05.%20sorting_Algorithm-img-%20(13).png)
```

- 👉 이미 정렬되어 있는 경우 → $O(N)$ (상수시간 복잡도)
