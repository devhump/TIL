---
tags: [Algorithm, python]
---

## 11. 플로이드 워셜 알고리즘(Floyd-Warshall Algorithm): 모든 출발지에서 다른 모든 출발지까지 최단 경로 계산


### 목차
```ad-note
- [[#11. 플로이드 워셜 알고리즘(Floyd-Warshall Algorithm): 모든 출발지에서 다른 모든 출발지까지 최단 경로 계산#플로이드 워셜 알고리즘 개요|플로이드 워셜 알고리즘 개요]]
- [[#11. 플로이드 워셜 알고리즘(Floyd-Warshall Algorithm): 모든 출발지에서 다른 모든 출발지까지 최단 경로 계산#플로이드 워셜 알고리즘|플로이드 워셜 알고리즘]]
- [[#11. 플로이드 워셜 알고리즘(Floyd-Warshall Algorithm): 모든 출발지에서 다른 모든 출발지까지 최단 경로 계산#플로이드 워셜 알고리즘: 동작 과정 살펴보기|플로이드 워셜 알고리즘: 동작 과정 살펴보기]]
- [[#11. 플로이드 워셜 알고리즘(Floyd-Warshall Algorithm): 모든 출발지에서 다른 모든 출발지까지 최단 경로 계산#플로이드 워셜 알고리즘: 코드 예시|플로이드 워셜 알고리즘: 코드 예시]]
- [[#11. 플로이드 워셜 알고리즘(Floyd-Warshall Algorithm): 모든 출발지에서 다른 모든 출발지까지 최단 경로 계산#플로이드 워셜 알고리즘 성능 분석|플로이드 워셜 알고리즘 성능 분석]]
```


### 플로이드 워셜 알고리즘 개요
- <u>모든 노드에서 다른 모든 노드까지의 최단 경로를 모두 계산</u>합니다.
- 플로이드 워셜(Floyd-Warshall) 알고리즘은 다익스트라 알고리즘과 마찬가지로 단계별로 **거쳐 가는 노드를 기준으로 알고리즘을 수행**합니다. 
	- 다만 매 단계마다 방문하지 않은 노드 중에 최단 거리를 갖는 노드를 찾는 과정이 필요하지 않습니다. 
- 플로이드 워셜은 2차원 테이블에 최단 거리 정보를 저장합니다. 
- 플로이드 워셜 알고리즘은 다이나믹 프로그래밍 유형에 속합니다. 

### 플로이드 워셜 알고리즘
- 각 단계마다 **특정한 노드 $K$를 거쳐 가는 경우를 확인**합니다. 
	- a에서 b로 가는 최단 거리보다 a에서 k를 거쳐 b로 가는 거리가 더 짧은지 검사합니다. 
- 점화식은 다음과 같습니다. 
$$D_{ab} = min(D_{ab}, D_{ak} + D_{kb})$$

- 👉 $D_{ab}$ 는 $a$에서 $b$까지의 거리, $D_{ak}, D_{kb}$는  $a-k$, $k-b$까지의 거리를 말한다. ($a$에서 $K$를 거쳐 $b$로 향하는 거리)

### 플로이드 워셜 알고리즘: 동작 과정 살펴보기
#### 초기상태.
- 그래프를 준비하고 최단 거리 테이블을 초기화 합니다. 
	- 기본 점화식: $D_{ab} = min(D_{ab}, D_{ak} + D_{kb})$

![](11.%20Floyd-Warshall%20Algorithm.png)

#### Step 1.
- **1번** 노드를 거쳐 가는 경우를 고려하여 테이블을 갱신합니다. 
	- 기본 점화식: $D_{ab} = min(D_{ab}, D_{a1} + D_{1b})$

$D_{23} = min(D_{23}, D_{21} + D_{13})$
$D_{24} = min(D_{24}, D_{21} + D_{14})$
$D_{32} = min(D_{32}, D_{31} + D_{12})$
$D_{34} = min(D_{34}, D_{31} + D_{14})$
$D_{42} = min(D_{42}, D_{41} + D_{12})$
$D_{43} = min(D_{43}, D_{41} + D_{13})$

![](11.%20Floyd-Warshall%20Algorithm-1.png)
- 👉1번열, 1번행, 자기자신으로 이동 하는 값 제외


#### Step 2.
- **2번** 노드를 거쳐 가는 경우를 고려하여 테이블을 갱신합니다. 
	- 기본 점화식: $D_{ab} = min(D_{ab}, D_{a2} + D_{2b})$

$D_{13} = min(D_{13}, D_{12} + D_{23})$
$D_{14} = min(D_{14}, D_{12} + D_{24})$
$D_{31} = min(D_{31}, D_{32} + D_{21})$
$D_{34} = min(D_{34}, D_{32} + D_{24})$
$D_{41} = min(D_{41}, D_{42} + D_{21})$
$D_{43} = min(D_{43}, D_{42} + D_{23})$

![](11.%20Floyd-Warshall%20Algorithm-2.png)
- 👉2번열, 2번행, 자기자신으로 이동 하는 값 제외

#### Step 3.
- **3번** 노드를 거쳐 가는 경우를 고려하여 테이블을 갱신합니다. 
	- 기본 점화식: $D_{ab} = min(D_{ab}, D_{a3} + D_{3b})$

$D_{12} = min(D_{12}, D_{13} + D_{32})$
$D_{14} = min(D_{14}, D_{13} + D_{34})$
$D_{21} = min(D_{21}, D_{23} + D_{31})$
$D_{24} = min(D_{24}, D_{23} + D_{34})$
$D_{41} = min(D_{41}, D_{43} + D_{31})$
$D_{42} = min(D_{42}, D_{43} + D_{32})$

![](11.%20Floyd-Warshall%20Algorithm-3.png)

- 👉 3번열, 3번행, 자기자신으로 이동 하는 값 제외


#### Step 4.
- **4번** 노드를 거쳐 가는 경우를 고려하여 테이블을 갱신합니다. 
	- 기본 점화식: $D_{ab} = min(D_{ab}, D_{a4} + D_{4b})$

$D_{12} = min(D_{12}, D_{14} + D_{42})$
$D_{13} = min(D_{14}, D_{14} + D_{43})$
$D_{21} = min(D_{21}, D_{24} + D_{41})$
$D_{23} = min(D_{23}, D_{24} + D_{43})$
$D_{31} = min(D_{31}, D_{34} + D_{41})$
$D_{32} = min(D_{32}, D_{34} + D_{42})$

![](11.%20Floyd-Warshall%20Algorithm-4.png)
- 👉 4번열, 4번행, 자기자신으로 이동 하는 값 제외


### 플로이드 워셜 알고리즘: 코드 예시
```python
INF = int(1e9) # 무한을 의미하는 값으로 10억을 설정

# 노드의 개수 및 간선의 개수를 입력받기
n = int(input()) 
m = int(input())
# 2차원 리스트(그래프 표현)을 만들고, 무한으로 초기화
graph = [[INF] * (n +1) for _ in range(n + 1)]

# 자기 자신에서 자기 자신으로 가는 비용은 0으로 초기화
for a in range(1, n + 1):
	for b in range(1, n + 1):
		if a == b:
			graph[a][b] = 0

# 각 간선에 대한 정보를 입력 받아, 그 값으로 초기화
for _ in range(m):
	# A에서 B로 가는 비용은 C라고 설정
	a, b, c = map(int, input().split())
	graph[a][b] = c

# 점화식에 따라 플로이드 워셜 알고리즘을 수행
for k in range(1, n + 1)
	for a in range(1, n + 1):
		for b in range(1, n + 1):
			graph[a][b] = min(graph[a][b], graph[a][k] + graph[k][b])

# 수행된 결과를 출력
for a in range(1, n + 1):
	for b in range(1, n + 1):
		# 도달할 수 없는 경우, 무한(INFINITY)이라고 출력
		if graph[a][b] == INF:
			print("INFINITY", end=" ")
		else:
			print(graph[a][b], end=" ")
	print()
```

### 플로이드 워셜 알고리즘 성능 분석
- 노드의 개수가 $N$개 일 떄 알고리즘상으로 $N$번의 단계를 수행합니다. 
	- 각 단계마다 $O(N^3)$의 연산을 통해 현재 노드를 거쳐 가는 모든 경로를 고려합니다. 
- 따라서 플로이드 워셜 알고리즘의 총 시간 복잡도는 $O(N^3)$입니다. 
	- 왜냐하면 3중 반복문으로 구성되기 때문에

- 👉 플로이드 워셜 문제는 노드 개수가 500개 이하 정도의 작은 값으로 구성되는 경우가 많고, 시간 제한이 넉넉하지 않다면 시간 초과 받을 가능성이 크다. 따라서 최단 거리 문제가 출제되면 다익스트라, 플로이드 워셜 등 **어떤 알고리즘이 적절한지 고민하고 나서 해답을 구해야 한다.** 
