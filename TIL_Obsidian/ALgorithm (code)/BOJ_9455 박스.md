- [BOJ_9455 박스](https://www.acmicpc.net/problem/9455)

### <문제> BOJ_9455 박스: 문제 설명
```ad-question
 - m행 n열로 이루어진 그리드가 주어진다. 일부 칸에는 박스가 들어 있다. 모든 박스가 더 이상 움직일 수 없을 때 까지 아래로 움직인다면, 박스는 쌓여진 상태가 된다.

- 그림 (a)의 그리드의 크기는 5행 4열이고, 7칸에는 박스가 들어있다. 모든 박스가 계속해서 아래로 움직이면, 그림 (b)와 같이 변하게 된다.

![](assets/BOJ_9455%20박스.png)

- 박스가 움직인 거리는 바닥에 쌓이기 전 까지 이동한 칸의 개수이다. 예를 들어, 맨 왼쪽 열에서 가장 위에 있는 박스가 움직인 거리는 2이다. 모든 박스가 이동한 거리 (각 박스가 이동한 거리의 합) 을 구하는 프로그램을 작성하시오. 위의 예제에서 박스 7개가 움직인 거리는 8이다.
```

```ad-attention
- 난이도: Bronze 1
- 시간제한: ==1초==
- 메모리 제한: ==256MB==

- ==입력== 
	- 첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스의 첫째 줄에는 m과 n이 주어진다. (1 ≤ m, n ≤ 100) 다음 m개 줄에는 그리드의 각 행의 정보를 나타내는 n개의 정수가 주어진다. 그리드 첫 행부터 마지막 행까지 순서대로 주어진다. 박스가 들어있는 칸은 1로, 다른 칸은 0으로 주어진다. 각 정수 사이에는 공백이 하나 주어진다.

- ==출력==
	- 각 테스트 케이스마다 입력으로 주어진 그리드에서 모든 박스가 이동한 거리를 출력한다.
- ==예제 입력==
	```python
	3
	5 4
	1 0 0 0
	0 0 1 0
	1 0 0 1
	0 1 0 0
	1 0 1 0
	3 3
	1 1 1
	1 1 1
	0 0 0
	5 6
	1 0 1 1 0 1
	0 0 0 0 0 0
	1 1 1 0 0 0
	0 0 0 1 1 1
	0 1 0 1 0 1
	```
- ==예제 출력==
	```python
	8
	6
	16
	```
```


#### 문제 해결 아이디어
```ad-example
1. Test Case 수 / 행과 열의 수 / input 값들을 각각 입력 받는다
2. 현 상태로는 조작이 어렵다고 판단, 행렬을 왼쪽으로 90도 회전한다.
	- ex) 5 by 4 → 4 by 5
3. 해당행에 1이 있는지 확인한다. 
	- '0000' 과 같이 0만 있는 행도 있지 않을까?
4. 이때 각 행에 1이 몇개 있는지 확인
5. `sum(matrix[i][1의 개수: ])`이 1의 개수와 같은지 확인하는 조건을 세운다
	- ⇒ 박스가 더 이상 움직일 필요가 없는지 확인하는 과정
6. 같지 않다면 0과 1의 위치를 계속 swipe 하면서 카운팅을 한다.
7. 각 케이스별로 카운팅한 결과를 출력한다.
```

#### 내 코드
```python
# BOJ_9455 박스
# ! 왜 또 테케는 맞는데, 틀렸다고 나오냐!!!!!

import sys
sys.stdin = open("BOJ_9455_input.txt", "r")

from pprint import pprint


T = int(input())

for t in range(T):
    # todo 입력 부분
    mn = list(map(int, input().split()))
    m = mn[0]
    n = mn[1]

    matrix = [[] for _ in range(m)]
    for i in range(m):
        matrix[i].extend(list(map(int, input().split())))

    # pprint(matrix)

    # todo 리스트 회전하는 부분
    t_mx = [[0]* m for _ in range(n)]

    for i in range(n):
        for j in range(m):
            t_mx[i][j] = matrix[j][i]

    # pprint(t_mx)

    cnt = 0
    for j in range(n):
        # todo 1이 (박스가) 없는 경우도 고려
        if 1 not in t_mx[j]:
            break
        one_cnt = t_mx[j].count(1) 
        
        while True:
        
            if one_cnt == sum(t_mx[j][-one_cnt:]):
                break
            # print("변하기 전", t_mx[j])
            for i in range(m-1):
                if t_mx[j][i] == 1 and t_mx[j][i+1] == 0:
                    t_mx[j][i+1] = 1
                    t_mx[j][i] = 0
                    cnt += 1
                    # print("변한 후", t_mx[j])
    print(cnt)
        


```