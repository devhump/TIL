#### 개요
- 개체를 구분할 수 있는 범위를 나타내는 namespace(이름 공간)에 대한 이래

#### Namespace의 필요성
- 두번째 app pages의 index 페이지를 작성해보고 <br>어떤 문제가 발생하는지 확인해보기
```python
# pages/urls.py
from django.urls import path
from . import views

urlpatterns = [
	path('index/', views.index, name='index'),
]

```

```python
# pages/views.py 

def index(request):
	return render(request, 'index.html')
```

```django
<!-- pages/templates/index.html -->

{% extends 'base.html' %}

{% block content %}
	<h1>두번째 앱의 index</h1>
{% endblock content %}
```

```django
<!-- articles/templates/index.html -->

{% extends 'base.html' %}

{% block content %}
	<h1>만나서 반가워요!</h1>
	<a href="{% url 'greeting' %}">greeting</a>
	<a href="{% url 'dinner' %}">dinner</a>
	<a href="{% url 'throw' %}">throw</a>
	
	<a href="{% url 'index' %}">두번째 앱 index로 이동</a>
{% endblock content %}
```


#### 2가지 문제 발생
1. articles app index 페이지에 작성한 두번째 앱 index로 이동하는 하이퍼 링크를 클 릭 시 현재 페이지로 다시 이동
	- URL namespace
2. pages app의 index url (http://127.0.0.1:8000/pages/index/)로 직접 이동해도 articles app의 index 페이지가 출력됨
	- Template namespace

### URL namespace
#### 개요
- URL namespace를 사용하면 서로 다른 앱에서 동일한 URL 이름을 사용하는 경우에도 **이름이 지정된 URL을 고유하게 사용** 할 수 있음
- **app_name attribute를 작성**해 URL namespace를 설정

```python
# articles/urls.py
app_name = 'articles'

urlpatterns = [
	...,
]
```

```python
# pages/urls.py
app_name = 'pages'

urlpatterns = [
	...,
]
```

#### URL tag의 변화
```django
{% url 'index' %}
```
- 👆 위에서 아래처럼 👇
```django
{% url 'articles:index' %}
```


- ==❖ app_name을 지정한 이후에는 url 태그에서 반드시 app_name:url_name 형태로만 사용해야 함. 그렇지 않으면 NoReverceMatch 에러가 발생==

```django
<!-- articles/templates/index.html -->
{% extends 'base.html' %}

{% block content %}
	<h1>만나서 반가워요!</h1>
	<a href="{% url 'articles:greeting' %}">greeting</a>
	<a href="{% url 'articles:dinner' %}">dinner</a>
	<a href="{% url 'articles:throw' %}">throw</a>

	<a href="{% url 'pages:index' %}">두번째 앱 index로 이동</a>
{% endblock %}
```

```django
<!-- throw.html -->
{% extends 'base.html' %}

{% block content %}
	<h1>Throw</h1>
	<form action="{% url 'articles:catch' %}" method="GET">
		<label for="message">Throw</label>
		<input type="text" id="message" name="message">
		<input type="submit" value="던져">
	</form>
	
	<a href="{% url 'articles:index' %}">뒤로</a>
{% endblock content %} 
```

```django
<!-- catch.html -->
<a href="{% url 'articles:throw' %}">다시 던지러</a>

<!-- greeting, dinner.html -->
<a href="{% url 'articles:index' %}">뒤로</a>
```

#### URL 참조
- “ : ” 연산자를 사용하여 지정
	- 예를 들어, app_name이 articles이고 URL name이 index인 주소 참조는 articles:index가 됨

```ad-tip
- 다시 한번 짚고가기!
	- 👉 [Template namespace](04.%20App%20URL%20mapping%20&%20Template%20namespace.md#Template%20namespace)
```

### Naming URL patterns
#### Naming URL patterns의 필요성
- 만약 “index/”의 문자열 주소를 “new-index/”로 바꿔야 한다고 가정해보자
- 그렇다면 “index/” 주소를 사용했던 모든 곳을 찾아서 변경해야 하는 번거로움이 발생함

#### Naming URL patterns
- 이제는 링크에 URL을 직접 작성하는 것이 아니라 “path()” 함수의 name 인자를 정의해서 사용
- DTL의 Tag 중 하나인 URL 태그를 사용해서 “path()” 함수에 작성한 name을 사용할 수 있음
- 이를 통해 URL 설정에 정의된 특정한 경로들의 의존성을 제거할 수 있음
- Django는 URL에 이름을 지정하는 방법을 제공함으로써 view 함수와 템플릿에서 <br>특정 주소를 쉽게 참조할 수 있도록 도움

```python
# articles/urls.py

urlpatterns = [
	path('index/', views.index, name='index'),
	path('greeting/', views.greeting, name='greeting'),
	path('dinner/', views.dinner, name='dinner'),
	path('throw/', views.throw, name='throw'),
	path('catch/', views.catch, name='catch'),
	path('hello/<str:name>/', views.hello, name='hello'),
]
```


#### Built-in tag – “url”
```django
{% url '' %}
```
- 주어진 URL 패턴 이름 및 선택적 매개 변수와 일치하는 절대 경로 주소를 반환
- 템플릿에 URL을 하드 코딩하지 않고도 DRY 원칙을 위반하지 않으면서 <br>링크를 출력하는 방법

```django
!-- catch.html -->
{% extends 'base.html' %}

{% block content %}
	<h1>Catch</h1>
	<h2>여기서 {{ message }}를 받았어!!</h2>
	<a href="{% url 'throw' %}">다시 던지러</a>
{% endblock content %}
```

```django
<!-- throw.html -->
{% extends 'base.html' %}

{% block content %}
	<h1>Throw</h1>
	<form action="{% url 'catch' %}" method="GET">
		...
	</form>
	
	<a href="{% url 'index' %}">뒤로</a>
{% endblock content %}
```

```django
<!-- index.html -->
{% extends 'base.html' %}

{% block content %}
	...
	<a href="{% url 'greeting' %}">greeting</a>
	<a href="{% url 'dinner' %}">dinner</a>
	<a href="{% url 'throw' %}">throw</a>
{% endblock content %}

<!-- dinner, greeting.html-->
<a href="{% url 'index' %}">뒤로</a>
```


#### url 태그 출력 확인하기
- 마지막으로 개발자 도구를 통해 url 태그가 URL 패턴 이름과 일치하는 <br>절대 경로 주소를 반환하는 것을 확인해보기

#### (참고) DRY 원칙
- Don’t Repeat Yourself의 약어
- 더 품질 좋은 코드를 작성하기 위해서 알고, 따르면 좋은 소프트웨어 원칙들 중 하나로 <br>**“소스 코드에서 동일한 코드를 반복하지 말자”** 라는 의미
- 동일한 코드가 반복된다는 것은 잠재적인 버그의 위협을 증가 시키고 반복되는 코드를 변경해야 하는 경우, 반복되는 모든 코드를 찾아서 수정해야 함
- 이는 프로젝트 규모가 커질수록 애플리케이션의 유지 보수 비용이 커짐


#### Django의 설계 철학 (Templates System)
1. “표현과 로직(view)을 분리”
	- 템플릿 시스템은 표현을 제어하는 도구이자 표현에 관련된 로직일 뿐
	- 즉, 템플릿 시스템은 이러한 기본 목표를 넘어서는 기능을 지원하지 말아야 함

1. “중복을 배제”
	- 대다수의 동적 웹사이트는 공통 header, footer, navbar 같은 사이트 공통 디자인을 갖음
	- Django 템플릿 시스템은 이러한 요소를 한 곳에 저장하기 쉽게 하여 중복 코드를 없애야 함
	- 템플릿 상속의 기초가 되는 철학


#### Framework의 성격
- 독선적(Opinionated)
	- 독선적인 프레임워크들은 어떤 특정 작업을 다루는 ‘올바른 방법’에 대한 분명한 의견(규약)을 가지고 있음
	- 대체로 특정 문제내에서 빠른 개발방법을 제시
	- 어떤 작업에 대한 올바른 방법이란 보통 잘 알려져 있고 문서화가 잘 되어있기 때문
	- 하지만 주요 상황을 벗어난 문제에 대해서는 그리 유연하지 못한 해결책을 제시할 수 있음

- 관용적(Unopinionated)
	- 관용적인 프레임워크들은 구성요소를 한데 붙여서 해결해야 한다거나 심지어 어떤 도구를 써야 한다는 '올바른 방법'에 대한 제약이 거의 없음
	- 이는 개발자들이 특정 작업을 완수하는데 가장 적절한 도구들을 이용할 수 있는 자유도가 높음
	- 하지만 개발자 스스로가 그 도구들을 찾아야 한다는 수고가 필요

#### Django Framework의 성격
- ‘다소 독선적’
	- 양쪽 모두에게 최선의 결과를 준다고 강조
- 결국 하고자 하는 말은 현대 개발에 있어서는 가장 중요한 것들 중 하나는 ‘생산성‘
- 프레임워크는 우리가 하는 개발을 방해하기 위해 규칙, 제약을 만들어 놓은 것이 아님
- 우리가 온전히 만들고자 하는 것에만 집중할 수 있게 도와주는 것
- “수레바퀴를 다시 만들지 말라.”

```ad-tip
- 다시 한번, 복습!
	- 👉[Django 구조 이해하기 (MTV Design Pattern)](01.%20Django%20Intro.md#Django%20구조%20이해하기%20(MTV%20Design%20Pattern))
```

## Django Model
### Database
- 체계화된 데이터의 모임
- 검색 및 구조화 같은 작업을 보다 쉽게 하기 위해 <br>조직화된 데이터를 수집하는 저장 시스템
- Database의 가장 기초적인 키워드에 대해 알아보고 자세한 내용은 추후 Database 시간에 다룰 예정
- Database 기본 구조
	1. 스키마(Schema)
	2. 테이블(Table)

```ad-tip
- 같이 보면 좋은 자료!
	- 👉[01. DB & RDBMS & SQL CRUD](../DB/01.%20DB%20&%20RDBMS%20&%20SQL%20CRUD.md)
```

#### 스키마(Schema)
- 뼈대(Structure)
- 데이터베이스에서 자료의 구조, 표현 방법, 관계 등을 정의한 구조
- 스키마 예시
| Column | datatype |
|:------:|:--------:|
|   id   |   INT    |
|  name  |   TEXT   |
|  age   |   INT    |
| email  |   TEXT   |


#### 테이블(Table)
- 필드와 레코드를 사용해 조직된 데이터 요소들의 집합
- 관계(Relation)라고도 부름
![](assets/05.%20Namespace.png)


##### 필드(field)
- 속성 혹은 컬럼(column)
- 각 필드에는 고유한 데이터 형식이 지정됨
	- INT, TEXT 등
![](assets/05.%20Namespace-1.png)

##### 레코드(record)
- 튜플 혹은 행(row)
- 테이블의 데이터는 레코드에 저장됨
- 예를 들어 해당 예시는 4명의 고객정보가 저장되어 있으며, 레코드는 4개가 존재
![](assets/05.%20Namespace-2.png)

##### PK (Primary Key)
- 기본 키
- 각 레코드의 고유한 값 (식별자로 사용)
- 기술적으로 다른 항목과 절대로 중복될 수 없는 단일 값(unique)
- 데이터베이스 관리 및 테이블 간 관계 설정 시 주요하게 활용 됨

![](assets/05.%20Namespace-3.png)

- PK (Primary Key) 예시
	- “주민등록번호”
		- 데이터베이스에 동일한 이름, 나이를 가진 사람들의 데이터는 존재할 수 있지만 각 사람들이 가진 주민등록번호는 절대 같을 수 없음
		- 즉, 주민등록번호는 그 사람을 나타내는 고유한 값으로써 사용할 수 있음

#### 쿼리(Query)
- 데이터를 조회하기 위한 명령어
- 조건에 맞는 데이터를 추출하거나 조작하는 명령어 <br>(주로 테이블형 자료구조에서)
- "Query를 날린다." 
	- 👉 “데이터베이스를 조작한다.”


### Model
#### 개요
- Django는 Model을 통해 데이터에 접근하고 조작
- 사용하는 데이터들의 필수적인 필드들과 동작들을 포함
- 저장된 데이터베이스의 구조 (layout)
- 일반적으로 각각의 모델은 하나의 데이터베이스 테이블에 매핑(mapping)
	- 모델 클래스 1개 == 데이터베이스 테이블 1개

- Model을 통해 데이터 관리
![](assets/05.%20Namespace-4.png)

- (참고) 매핑
	- Mapping
	- 하나의 값을 다른 값으로 대응시키는 것

#### Model 작성하기
- 새 프로젝트(crud), 앱(articles) 작성 및 앱 등록
```shell
$ django-admin startproject crud .
$ python manage.py startapp articles
```

```python
# settings.py

INSTALLED_APPS = [
	'articles',
	...
]
```

- models.py 작성
	- 모델 클래스를 작성하는 것은 데이터베이스 테이블의 스키마를 정의하는 것
	- ”모델 클래스 == 테이블 스키마”

```python
# articles/models.py

class Article(models.Model):
	title = models.CharField(max_length=10)
	content = models.TextField()
```


#### Model 이해하기
- 각 모델은 django.models.Model 클래스의 서브 클래스
	- 즉, 각 모델은 django.db.models 모듈의 Model 클래스를 상속받아 구성됨
	- 클래스 상속 기반 형태의 Django 프레임워크 개발
		- 👉 프레임워크에서는 잘 만들어진 도구를 가져다가 잘 쓰는 것

![](assets/05.%20Namespace-5.png)

- models 모듈을 통해 어떠한 타입의 DB 필드(컬럼)을 정의할 것인지 정의
	- Article에는 어떤 데이터 구조가 필요한지 정의
	- 클래스 변수 title과 content은 DB 필드를 나타냄

![](assets/05.%20Namespace-6.png)

1. 클래스 변수(속성)명
	- DB 필드의 이름

2. 클래스 변수 값 (models 모듈의 Field 클래스)
	- DB 필드의 데이터 타입

#### Django Model Field
- Django는 모델 필드를 통해 테이블의 필드(컬럼)에 저장할 <br>데이터 유형 (INT, TEXT 등)을 정의
- 데이터 유형에 따라 다양한 모델 필드를 제공
	- DataField(), CharField(), IntegerField() 등
	- https://docs.djangoproject.com/en/3.2/ref/models/fields/


#### 사용한 모델 필드 알아보기
- `CharField(max_length=None, **options)`
	- 길이의 제한이 있는 문자열을 넣을 때 사용
	- max_length
		- 필드의 최대 길이(문자) 
		- CharField의 필수 인자
		- 데이터베이스와 Django의 유효성 검사(값을 검증하는 것)에서 활용됨

- `TextField(**options)`
	- 글자의 수가 많을 때 사용
	- max_length 옵션 작성 시 사용자 입력 단계에서는 반영 되지만,  <br>모델과 데이터베이스 단계에는 적용되지 않음 (CharField를 사용해야 함)
		- 실제로 저장될 때 길이에 대한 유효성을 검증하지 않음


#### 데이터베이스 스키마
- 지금까지 작성한 models.py는 다음과 같은 데이터베이스 스키마를 정의한 것
- 이제 이러한 모델의 변경사항을 실제 데이터베이스에 반영하기 위한 과정이 필요

| Column  | Data Type   |
| ------- | ----------- |
| title   | VARCHAR(10) |
| content | TEXT        |


### migrations
#### Migrations 관련 주요 명령어
1. makemigrations
2. migrate

#### makemigrations
- 모델의 변경사항에 대한 새로운 migration을 만들 때 사용
```shell
$ python manage.py makemigrations
```

- 명령어 실행 후 migrations/0001_initial.py가 생성된 것을 확인
- “파이썬으로 작성된 설계도”

![](assets/05.%20Namespace-7.png)

#### migrate
- **makemigrations**로 만든 설계도를 실제 데이터베이스에 반영하는 과정 <br>(db.sqlite3 파일에 반영)
- 결과적으로 모델의 변경사항과 데이터베이스를 동기화

```shell
$ python manage.py migrate
```

- 설계도(migration)를 실제 db.sqlite3 DB 파일에 반영
![](assets/05.%20Namespace-8.png)

#### (참고) Migrations 기타 명령어
```shell
$ python manage.py showmigrations
```
1. **showmigrations**
	- migrations 파일들이 migrate 됐는지 안됐는지 여부를 확인하는 용도
	- `[X]` 표시가 있으면 migrate가 완료되었음을 의미

```shell
$ python manage.py sqlmigrate articles 0001
```
2. **sqlmigrate**
	- 해당 migrations 파일이 SQL 문으로 어떻게 해석 될 지 미리 확인 할 수 있음


### 추가 필드 정의
#### Model 변경사항 반영하기
- models.py에 변경사항이 생겼을 때 어떤 과정의 migration이 필요할까?
- 추가 모델 필드 작성 후 다시 한번 makemigrations 진행

```python
# articles/models.py

class Article(models.Model):
	title = models.CharField(max_length=10)
	content = models.TextField()
	created_at = models.DateTimeField(auto_now_add=True)
	updated_at = models.DateTimeField(auto_now=True)
```

![](assets/05.%20Namespace-9.png)

```shell
$ python manage.py makemigrations
```

- 기존에 id, title, content 필드를 가진 테이블에 2개의 필드가 추가되는 상황
- Django 입장에서는 이미 존재하는 테이블에 새로운 컬럼이 추가되는 요구 사항을 받았는데, <br>이러한 컬럼들은 기본적으로 빈 값을 갖고 추가될 수 없음
	- 그래서 Django는 우리에게 추가되는 컬럼에 대한 기본 값을 설정해야 하니 <br>어떤 값을 설정할 것인지를 물어보는 과정을 진행

![](assets/05.%20Namespace-10.png)

- 각 보기 번호의 의미
	1. 다음 화면으로 넘어가서 새 컬럼의 기본 값을 직접 입력하는 방법
	2. 현재 과정에서 나가고 모델 필드에 default 속성을 직접 작성하는 방법
- “1”을 입력 후 Enter (created_at 필드에 대한 default 값 설정)

![](assets/05.%20Namespace-11.png)

- 다음 화면에서 **아무것도 입력하지 않고 Enter를 입력하면** Django에서 기본적으로 파이썬의 timezone 모듈의 now 메서드 반환 값을 기본 값으로 사용하도록 해줌

- 새로운 설계도(마이그레이션 파일)가 만들어 진 것을 확인
![](assets/05.%20Namespace-12.png)

- 새로운 설계도를 생성했기 때문에 DB와 동기화를 진행해야 함 <br>(아직 DB에는 변경사항이 반영하지 않았기 때문)

```shell
python manage.py migrate
```


#### DateTimeField()
- Python의 datetime.datetime 인스턴스로 표시되는 날짜 및 시간을 값으로 사용하는 필드
- DateField를 상속받는 클래스
- 선택 인자
	1. auto_now_add
		- 최초 생성 일자 (Useful for creation of timestamps)
		- 데이터가 실제로 만들어질 때 현재 날짜와 시간으로 자동으로 초기화 되도록 함
	2. auto_now
		- 최종 수정 일자 (Useful for “last-modified” timestamps)
		- 데이터가 수정될 때마다 현재 날짜와 시간으로 자동으로 갱신되도록 함

```ad-tip
#### 반드시 기억해야 할 migration 3단계
1. models.py에서 변경사항이 발생하면
2. migration 생성
	- makemigrations
3. DB 반영 (모델과 DB의 동기화)
	- migrate


- ==📌makemigrations & migrate==
```
%% '맼마마' %%

#### 그런데 설계도는 어떻게, 누가 해석할까
- makemigrations로 인해 만들어진 설계도는 파이썬으로 작성되어있음
- 그런데 SQL만 알아 들을 수 있다는 DB가 어떻게 이 설계도를 이해하고 동기화를 이룰 수 있을까?
- 바로 이 과정에서 중간에 번역을 담당하는 것이 **ORM**


### ORM
#### 개요
- Object-Relational-Mapping
- 객체 지향 프로그래밍 언어를 사용하여 호환되지 않는 유형의 시스템 간에 <br>(Django <-> DB) 데이터를 변환하는 프로그래밍 기술
- 객체 지향 프로그래밍에서 데이터베이스을 연동할 때, 데이터베이스와 <br>객체 지향 프로그래밍 언어 간의 호환되지 않는 데이터를 변환하는 프로그래밍 기법
- Django는 내장 Django ORM을 사용
- 한 마디로 SQL을 사용하지 않고 데이터베이스를 조작할 수 있게 만들어주는 매개체

- ORM 예시
![](assets/05.%20Namespace-13.png)^[https://soshace.com/optimizing-database-interactions-in-python-sqlalchemy-best-practices/]

#### ORM 장단점
- 장점
	-  SQL을 잘 알지 못해도 객체지향 언어로 DB 조작이 가능
	- 객체 지향적 접근으로 인한 높은 생산성
- 단점
	- ORM 만으로 세밀한 데이터베이스 조작을 구현하기 어려운 경우가 있음

#### ORM을 사용하는 이유
- “생산성”
- 현시대 개발에서 가장 중요한 키워드는 바로 생산성
- 우리는 DB를 객체(object)로 조작하기 위해 ORM을 사용할 것


### QuerySet API - intro
#### 외부 라이브러리 설치 및 설정
- 실습 편의를 위한 추가 라이브러리 설치 및 설정
```shell
pip install ipython
pip install django-extensions
```

```python
# settings.py

INSTALLED_APPS = [
	'articles',
	'django_extensions', # 이 부분 추가하기
		...,
]
```

- 패키지 목록 업데이트
```python
pip freeze > requirements.txt
```


#### (참고) IPython & django-extensions
- IPython
	- 파이썬 기본 쉘보다 더 강력한 파이썬 쉘
	- django-extensions
- django-extensions
	- Django 확장 프로그램 모음
	- shell_plus, graph model 등 다양한 확장 기능 제공

#### (참고) Shell
- 운영체제 상에서 다양한 기능과 서비스를 구현하는 인터페이스를 제공하는 프로그램 
- Shell(껍데기), 사용자와 운영 체제의 내부사이의 인터페이스를 감싸는 층이기 때문에 그러한 이름이 붙음 
- “사용자 ↔ 셸 ↔ 운영체제"


#### (참고) Python Shell
- 파이썬 코드를 실행해주는 인터프리터
	- 인터프리터 : 코드를 한 줄 씩 읽어 내려가며 실행하는 프로그램
- 인터렉티브 혹은 대화형 shell 이라고 부름
- Python 명령어를 실행하여 그 결과를 바로 제공

```shell
# git bash (windows)
$ python -i

# zsh (macOS)
$ python
```

#### Django shell
- ORM 관련 구문 연습을 위해 파이썬 쉘 환경을 사용
- 다만 일반 파이썬 쉘을 통해서는 장고 프로젝트 환경에 영향을 줄 수 없기 때문에 <br>Django환경 안에서 진행할 수 있는 Django shell을 사용
- 원래는 다음과 같은 명령어를 통해 Django shell을 사용하지만
```shell
python manage.py shell
```

- django-extension이 제공하는 더 강력한 shell_plus로 진행
```shell
python manage.py shell_plus
```

![](assets/05.%20Namespace-14.png)

#### 첫 ORM 명령어 사용하기
![](assets/05.%20Namespace-15.png)
- 이제 ORM 명령어의 구조와 QuerySet에 대해 알아보자

### QuerySet API
#### Database API
- Django가 제공하는 ORM을 사용해 데이터베이스를 조작하는 방법
-  Model을 정의하면 데이터를 만들고 읽고 수정하고 지울 수 있는 API를 제공

- Database API 구문
![](assets/05.%20Namespace-16.png)

#### Objects manager
- Django 모델이 데이터베이스 쿼리 작업을 가능하게 하는 인터페이스
- Django는 기본적으로 모든 Django 모델 클래스에 대해 objects 라는 <br>Manager 객체를 자동으로 추가함
- 이 Manager를 통해 특정 데이터를 조작할 수 있음
- DB를 Python class로 조작할 수 있도록 여러 메서드를 제공하는 manager


#### Query
- 데이터베이스에 특정한 데이터를 보여 달라는 요청
	- "쿼리문을 작성한다."
		- → 원하는 데이터를 얻기 위해 데이터베이스에 요청을 보낼 코드를 작성한다.
- 이 때, 파이썬으로 작성한 코드가 ORM의 의해 SQL로 변환되어 데이터베이스에 <br>전달되며, 데이터베이스의 응답 데이터를 **ORM이 QuerySet이라는 자료 형태로 변환**하여 <br>우리에게 전달


#### QuerySet
- 데이터베이스에게서 전달 받은 객체 목록(데이터 모음)
- 순회가 가능한 데이터로써 1개 이상의 데이터를 불러와 사용할 수 있음
- Django ORM을 통해 만들어진 자료형이며, 필터를 걸거나 정렬 등을 수행할 수 있음
- objects manager를 사용하여 복수의 데이터를 가져오는 queryset method를 사용할 때 반환되는 객체
- 단, 데이터베이스가 단일한 객체를 반환 할 때는 QuerytSet이 아닌 모델(Class)의 인스턴스로 반환됨

#### QuerySet API
- QuerySet과 상호작용하기 위해 사용하는 도구 (메서드, 연산자 등)
![](assets/05.%20Namespace-17.png)


### QuerySet API 익히기
#### QuerySet API 익히기
- Queryset API를 활용해 데이터를 생성하고, 읽고, 수정하고 삭제해보기

- **CRUD**
	- Create / Read / Update / Delete
		- 생성 / 조회 / 수정 / 삭제
	- 대부분의 컴퓨터 소프트웨어가 가지는 기본적인 데이터 처리 기능 4가지를 묶어서 일컫는 말

